{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * TSBuffer Validator v2.1.1\n * -----------------------------------------\n * MIT LICENSE\n * KingWorks (C) Copyright 2022\n * https://github.com/k8w/tsbuffer-validator\n */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('k8w-extend-native');\nvar tslib = require('tslib');\nvar tsbufferSchema = require('tsbuffer-schema');\n\nvar ProtoHelper = /** @class */ (function () {\r\n    function ProtoHelper(proto) {\r\n        this._schemaWithUuids = [];\r\n        this._unionPropertiesCache = {};\r\n        this._flatInterfaceSchemaCache = {};\r\n        this.proto = proto;\r\n    }\r\n    /** 将ReferenceTypeSchema层层转换为它最终实际引用的类型 */\r\n    ProtoHelper.prototype.parseReference = function (schema) {\r\n        // Reference\r\n        if (schema.type === tsbufferSchema.SchemaType.Reference) {\r\n            var parsedSchema = this.proto[schema.target];\r\n            if (!parsedSchema) {\r\n                throw new Error(\"Cannot find reference target: \".concat(schema.target));\r\n            }\r\n            if (this.isTypeReference(parsedSchema)) {\r\n                return this.parseReference(parsedSchema);\r\n            }\r\n            else {\r\n                return parsedSchema;\r\n            }\r\n        }\r\n        // IndexedAccess\r\n        else if (schema.type === tsbufferSchema.SchemaType.IndexedAccess) {\r\n            if (!this.isInterface(schema.objectType)) {\r\n                throw new Error(\"Error objectType: \".concat(schema.objectType.type));\r\n            }\r\n            // find prop item\r\n            var flat = this.getFlatInterfaceSchema(schema.objectType);\r\n            var propItem = flat.properties.find(function (v) { return v.name === schema.index; });\r\n            var propType = void 0;\r\n            if (propItem) {\r\n                propType = propItem.type;\r\n            }\r\n            else {\r\n                if (flat.indexSignature) {\r\n                    propType = flat.indexSignature.type;\r\n                }\r\n                else {\r\n                    throw new Error(\"Error index: \".concat(schema.index));\r\n                }\r\n            }\r\n            // optional -> | undefined\r\n            if (propItem && propItem.optional && // 引用的字段是optional\r\n                (propItem.type.type !== tsbufferSchema.SchemaType.Union // 自身不为Union\r\n                    // 或自身为Union，但没有undefined成员条件\r\n                    || propItem.type.members.findIndex(function (v) { return v.type.type === tsbufferSchema.SchemaType.Literal && v.type.literal === undefined; }) === -1)) {\r\n                propType = {\r\n                    type: tsbufferSchema.SchemaType.Union,\r\n                    members: [\r\n                        { id: 0, type: propType },\r\n                        {\r\n                            id: 1,\r\n                            type: {\r\n                                type: tsbufferSchema.SchemaType.Literal,\r\n                                literal: undefined\r\n                            }\r\n                        }\r\n                    ]\r\n                };\r\n            }\r\n            return this.isTypeReference(propType) ? this.parseReference(propType) : propType;\r\n        }\r\n        else if (schema.type === tsbufferSchema.SchemaType.Keyof) {\r\n            var flatInterface = this.getFlatInterfaceSchema(schema.target);\r\n            return {\r\n                type: tsbufferSchema.SchemaType.Union,\r\n                members: flatInterface.properties.map(function (v, i) { return ({\r\n                    id: i,\r\n                    type: {\r\n                        type: tsbufferSchema.SchemaType.Literal,\r\n                        literal: v.name\r\n                    }\r\n                }); })\r\n            };\r\n        }\r\n        else {\r\n            return schema;\r\n        }\r\n    };\r\n    ProtoHelper.prototype.isInterface = function (schema, excludeReference) {\r\n        if (excludeReference === void 0) { excludeReference = false; }\r\n        if (!excludeReference && this.isTypeReference(schema)) {\r\n            var parsed = this.parseReference(schema);\r\n            return this.isInterface(parsed, excludeReference);\r\n        }\r\n        else {\r\n            return schema.type === tsbufferSchema.SchemaType.Interface || this.isMappedType(schema) && this.parseMappedType(schema).type === tsbufferSchema.SchemaType.Interface;\r\n        }\r\n    };\r\n    ProtoHelper.prototype.isMappedType = function (schema) {\r\n        return schema.type === tsbufferSchema.SchemaType.Pick ||\r\n            schema.type === tsbufferSchema.SchemaType.Partial ||\r\n            schema.type === tsbufferSchema.SchemaType.Omit ||\r\n            schema.type === tsbufferSchema.SchemaType.Overwrite;\r\n    };\r\n    ProtoHelper.prototype.isTypeReference = function (schema) {\r\n        return schema.type === tsbufferSchema.SchemaType.Reference || schema.type === tsbufferSchema.SchemaType.IndexedAccess || schema.type === tsbufferSchema.SchemaType.Keyof;\r\n    };\r\n    ProtoHelper.prototype._getSchemaUuid = function (schema) {\r\n        var schemaWithUuid = schema;\r\n        if (!schemaWithUuid.uuid) {\r\n            schemaWithUuid.uuid = this._schemaWithUuids.push(schemaWithUuid);\r\n        }\r\n        return schemaWithUuid.uuid;\r\n    };\r\n    ProtoHelper.prototype.getUnionProperties = function (schema) {\r\n        var uuid = this._getSchemaUuid(schema);\r\n        if (!this._unionPropertiesCache[uuid]) {\r\n            this._unionPropertiesCache[uuid] = this._addUnionProperties([], schema.members.map(function (v) { return v.type; }));\r\n        }\r\n        return this._unionPropertiesCache[uuid];\r\n    };\r\n    /**\r\n     * unionProperties: 在Union或Intersection类型中，出现在任意member中的字段\r\n     */\r\n    ProtoHelper.prototype._addUnionProperties = function (unionProperties, schemas) {\r\n        for (var i = 0, len = schemas.length; i < len; ++i) {\r\n            var schema = this.parseReference(schemas[i]);\r\n            // Interface及其Ref 加入interfaces\r\n            if (this.isInterface(schema)) {\r\n                var flat = this.getFlatInterfaceSchema(schema);\r\n                flat.properties.forEach(function (v) {\r\n                    unionProperties.binaryInsert(v.name, true);\r\n                });\r\n                if (flat.indexSignature) {\r\n                    var key = \"[[\".concat(flat.indexSignature.keyType, \"]]\");\r\n                    unionProperties.binaryInsert(key, true);\r\n                }\r\n            }\r\n            // Intersection/Union 递归合并unionProperties\r\n            else if (schema.type === tsbufferSchema.SchemaType.Intersection || schema.type === tsbufferSchema.SchemaType.Union) {\r\n                this._addUnionProperties(unionProperties, schema.members.map(function (v) { return v.type; }));\r\n            }\r\n            else if (this.isMappedType(schema)) {\r\n                this._addUnionProperties(unionProperties, [this.parseMappedType(schema)]);\r\n            }\r\n        }\r\n        return unionProperties;\r\n    };\r\n    /**\r\n     * 将unionProperties 扩展到 InterfaceTypeSchema中（optional的any类型）\r\n     * 以此来跳过对它们的检查（用于Intersection/Union）\r\n     */\r\n    ProtoHelper.prototype.applyUnionProperties = function (schema, unionProperties) {\r\n        var newSchema = tslib.__assign(tslib.__assign({}, schema), { properties: schema.properties.slice() });\r\n        var _loop_1 = function (prop) {\r\n            if (prop === '[[String]]') {\r\n                newSchema.indexSignature = newSchema.indexSignature || {\r\n                    keyType: tsbufferSchema.SchemaType.String,\r\n                    type: { type: tsbufferSchema.SchemaType.Any }\r\n                };\r\n            }\r\n            else if (prop === '[[Number]]') {\r\n                newSchema.indexSignature = newSchema.indexSignature || {\r\n                    keyType: tsbufferSchema.SchemaType.Number,\r\n                    type: { type: tsbufferSchema.SchemaType.Any }\r\n                };\r\n            }\r\n            else if (!schema.properties.find(function (v) { return v.name === prop; })) {\r\n                newSchema.properties.push({\r\n                    id: -1,\r\n                    name: prop,\r\n                    optional: true,\r\n                    type: {\r\n                        type: tsbufferSchema.SchemaType.Any\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        for (var _i = 0, unionProperties_1 = unionProperties; _i < unionProperties_1.length; _i++) {\r\n            var prop = unionProperties_1[_i];\r\n            _loop_1(prop);\r\n        }\r\n        return newSchema;\r\n    };\r\n    /**\r\n     * 将interface及其引用转换为展平的schema\r\n     */\r\n    ProtoHelper.prototype.getFlatInterfaceSchema = function (schema) {\r\n        var uuid = this._getSchemaUuid(schema);\r\n        // from cache\r\n        if (this._flatInterfaceSchemaCache[uuid]) {\r\n            return this._flatInterfaceSchemaCache[uuid];\r\n        }\r\n        if (this.isTypeReference(schema)) {\r\n            var parsed = this.parseReference(schema);\r\n            if (parsed.type !== tsbufferSchema.SchemaType.Interface) {\r\n                throw new Error(\"Cannot flatten non interface type: \".concat(parsed.type));\r\n            }\r\n            this._flatInterfaceSchemaCache[uuid] = this.getFlatInterfaceSchema(parsed);\r\n        }\r\n        else if (schema.type === tsbufferSchema.SchemaType.Interface) {\r\n            this._flatInterfaceSchemaCache[uuid] = this._flattenInterface(schema);\r\n        }\r\n        else if (this.isMappedType(schema)) {\r\n            this._flatInterfaceSchemaCache[uuid] = this._flattenMappedType(schema);\r\n        }\r\n        else {\r\n            // @ts-expect-error\r\n            throw new Error('Invalid interface type: ' + schema.type);\r\n        }\r\n        return this._flatInterfaceSchemaCache[uuid];\r\n    };\r\n    /**\r\n     * 展平interface\r\n     */\r\n    ProtoHelper.prototype._flattenInterface = function (schema) {\r\n        var properties = {};\r\n        var indexSignature;\r\n        // 自身定义的properties和indexSignature优先级最高\r\n        if (schema.properties) {\r\n            for (var _i = 0, _a = schema.properties; _i < _a.length; _i++) {\r\n                var prop = _a[_i];\r\n                properties[prop.name] = {\r\n                    optional: prop.optional,\r\n                    type: prop.type\r\n                };\r\n            }\r\n        }\r\n        if (schema.indexSignature) {\r\n            indexSignature = schema.indexSignature;\r\n        }\r\n        // extends的优先级次之，补全没有定义的字段\r\n        if (schema.extends) {\r\n            for (var _b = 0, _c = schema.extends; _b < _c.length; _b++) {\r\n                var extend = _c[_b];\r\n                // 解引用\r\n                var parsedExtRef = this.parseReference(extend.type);\r\n                if (this.isMappedType(parsedExtRef)) {\r\n                    parsedExtRef = this._flattenMappedType(parsedExtRef);\r\n                }\r\n                if (!this.isInterface(parsedExtRef)) {\r\n                    throw new Error('SchemaError: extends must from interface but from ' + parsedExtRef.type);\r\n                }\r\n                // 递归展平extends\r\n                var flatenExtendsSchema = this.getFlatInterfaceSchema(parsedExtRef);\r\n                // properties\r\n                if (flatenExtendsSchema.properties) {\r\n                    for (var _d = 0, _e = flatenExtendsSchema.properties; _d < _e.length; _d++) {\r\n                        var prop = _e[_d];\r\n                        if (!properties[prop.name]) {\r\n                            properties[prop.name] = {\r\n                                optional: prop.optional,\r\n                                type: prop.type\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n                // indexSignature\r\n                if (flatenExtendsSchema.indexSignature && !indexSignature) {\r\n                    indexSignature = flatenExtendsSchema.indexSignature;\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            type: tsbufferSchema.SchemaType.Interface,\r\n            properties: Object.entries(properties).map(function (v, i) { return ({\r\n                id: i,\r\n                name: v[0],\r\n                optional: v[1].optional,\r\n                type: v[1].type\r\n            }); }),\r\n            indexSignature: indexSignature\r\n        };\r\n    };\r\n    /** 将MappedTypeSchema转换为展平的Interface\r\n     */\r\n    ProtoHelper.prototype._flattenMappedType = function (schema) {\r\n        // target 解引用\r\n        var target;\r\n        if (this.isTypeReference(schema.target)) {\r\n            var parsed = this.parseReference(schema.target);\r\n            target = parsed;\r\n        }\r\n        else {\r\n            target = schema.target;\r\n        }\r\n        var flatTarget;\r\n        // 内层仍然为MappedType 递归之\r\n        if (target.type === tsbufferSchema.SchemaType.Pick || target.type === tsbufferSchema.SchemaType.Partial || target.type === tsbufferSchema.SchemaType.Omit || target.type === tsbufferSchema.SchemaType.Overwrite) {\r\n            flatTarget = this._flattenMappedType(target);\r\n        }\r\n        else if (target.type === tsbufferSchema.SchemaType.Interface) {\r\n            flatTarget = this._flattenInterface(target);\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid target.type: \".concat(target.type));\r\n        }\r\n        // 开始执行Mapped逻辑\r\n        if (schema.type === tsbufferSchema.SchemaType.Pick) {\r\n            var properties = [];\r\n            var _loop_2 = function (key) {\r\n                var propItem = flatTarget.properties.find(function (v) { return v.name === key; });\r\n                if (propItem) {\r\n                    properties.push({\r\n                        id: properties.length,\r\n                        name: key,\r\n                        optional: propItem.optional,\r\n                        type: propItem.type\r\n                    });\r\n                }\r\n                else if (flatTarget.indexSignature) {\r\n                    properties.push({\r\n                        id: properties.length,\r\n                        name: key,\r\n                        type: flatTarget.indexSignature.type\r\n                    });\r\n                }\r\n            };\r\n            for (var _i = 0, _a = schema.keys; _i < _a.length; _i++) {\r\n                var key = _a[_i];\r\n                _loop_2(key);\r\n            }\r\n            return {\r\n                type: tsbufferSchema.SchemaType.Interface,\r\n                properties: properties\r\n            };\r\n        }\r\n        else if (schema.type === tsbufferSchema.SchemaType.Partial) {\r\n            for (var _b = 0, _c = flatTarget.properties; _b < _c.length; _b++) {\r\n                var v = _c[_b];\r\n                v.optional = true;\r\n            }\r\n            return flatTarget;\r\n        }\r\n        else if (schema.type === tsbufferSchema.SchemaType.Omit) {\r\n            var _loop_3 = function (key) {\r\n                flatTarget.properties.removeOne(function (v) { return v.name === key; });\r\n            };\r\n            for (var _d = 0, _e = schema.keys; _d < _e.length; _d++) {\r\n                var key = _e[_d];\r\n                _loop_3(key);\r\n            }\r\n            return flatTarget;\r\n        }\r\n        else if (schema.type === tsbufferSchema.SchemaType.Overwrite) {\r\n            var overwrite = this.getFlatInterfaceSchema(schema.overwrite);\r\n            if (overwrite.indexSignature) {\r\n                flatTarget.indexSignature = overwrite.indexSignature;\r\n            }\r\n            var _loop_4 = function (prop) {\r\n                flatTarget.properties.removeOne(function (v) { return v.name === prop.name; });\r\n                flatTarget.properties.push(prop);\r\n            };\r\n            for (var _f = 0, _g = overwrite.properties; _f < _g.length; _f++) {\r\n                var prop = _g[_f];\r\n                _loop_4(prop);\r\n            }\r\n            return flatTarget;\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown type: \".concat(schema.type));\r\n        }\r\n    };\r\n    ProtoHelper.prototype.parseMappedType = function (schema) {\r\n        // 解嵌套，例如：Pick<Pick<Omit, XXX, 'a'|'b'>>>\r\n        var parents = [];\r\n        var child = schema;\r\n        do {\r\n            parents.push(child);\r\n            child = this.parseReference(child.target);\r\n        } while (this.isMappedType(child));\r\n        // 最内层是 interface，直接返回（validator 会验证 key 匹配）\r\n        if (child.type === tsbufferSchema.SchemaType.Interface) {\r\n            return child;\r\n        }\r\n        // PickOmit<A|B> === PickOmit<A> | PickOmit<B>\r\n        else if (child.type === tsbufferSchema.SchemaType.Union || child.type === tsbufferSchema.SchemaType.Intersection) {\r\n            var newSchema = {\r\n                type: child.type,\r\n                members: child.members.map(function (v) {\r\n                    // 从里面往外装\r\n                    var type = v.type;\r\n                    for (var i = parents.length - 1; i > -1; --i) {\r\n                        var parent_1 = parents[i];\r\n                        type = tslib.__assign(tslib.__assign({}, parent_1), { target: type });\r\n                    }\r\n                    return {\r\n                        id: v.id,\r\n                        type: type\r\n                    };\r\n                })\r\n            };\r\n            return newSchema;\r\n        }\r\n        else {\r\n            throw new Error(\"Unsupported pattern \".concat(schema.type, \"<\").concat(child.type, \">\"));\r\n        }\r\n    };\r\n    return ProtoHelper;\r\n}());\n\nvar _a;\r\n/** @internal */\r\nvar ErrorType;\r\n(function (ErrorType) {\r\n    ErrorType[\"TypeError\"] = \"TypeError\";\r\n    ErrorType[\"InvalidScalarType\"] = \"InvalidScalarType\";\r\n    ErrorType[\"TupleOverLength\"] = \"TupleOverLength\";\r\n    ErrorType[\"InvalidEnumValue\"] = \"InvalidEnumValue\";\r\n    ErrorType[\"InvalidLiteralValue\"] = \"InvalidLiteralValue\";\r\n    ErrorType[\"MissingRequiredProperty\"] = \"MissingRequiredProperty\";\r\n    ErrorType[\"ExcessProperty\"] = \"ExcessProperty\";\r\n    ErrorType[\"InvalidNumberKey\"] = \"InvalidNumberKey\";\r\n    ErrorType[\"UnionTypesNotMatch\"] = \"UnionTypesNotMatch\";\r\n    ErrorType[\"UnionMembersNotMatch\"] = \"UnionMembersNotMatch\";\r\n    ErrorType[\"CustomError\"] = \"CustomError\";\r\n})(ErrorType || (ErrorType = {}));\r\n/** @internal */\r\nvar ErrorMsg = (_a = {},\r\n    _a[ErrorType.TypeError] = function (expect, actual) { return \"Expected type to be `\".concat(expect, \"`, actually `\").concat(actual, \"`.\"); },\r\n    _a[ErrorType.InvalidScalarType] = function (value, scalarType) { return \"`\".concat(value, \"` is not a valid `\").concat(scalarType, \"`.\"); },\r\n    _a[ErrorType.TupleOverLength] = function (valueLength, schemaLength) { return \"Value has \".concat(valueLength, \" elements but schema allows only \").concat(schemaLength, \".\"); },\r\n    _a[ErrorType.InvalidEnumValue] = function (value) { return \"`\".concat(value, \"` is not a valid enum member.\"); },\r\n    _a[ErrorType.InvalidLiteralValue] = function (expected, actual) { return \"Expected to equals `\".concat(stringify(expected), \"`, actually `\").concat(stringify(actual), \"`\"); },\r\n    _a[ErrorType.MissingRequiredProperty] = function (propName) { return \"Missing required property `\".concat(propName, \"`.\"); },\r\n    _a[ErrorType.ExcessProperty] = function (propName) { return \"Excess property `\".concat(propName, \"` should not exists.\"); },\r\n    _a[ErrorType.InvalidNumberKey] = function (key) { return \"`\".concat(key, \"` is not a valid key, the key here should be a `number`.\"); },\r\n    // Union\r\n    _a[ErrorType.UnionTypesNotMatch] = function (value, types) { return \"`\".concat(stringify(value), \"` is not matched to `\").concat(types.join(' | '), \"`\"); },\r\n    _a[ErrorType.UnionMembersNotMatch] = function (memberErrors) { return \"No union member matched, detail:\\n\".concat(memberErrors.map(function (v, i) { return \"  <\".concat(i, \"> \").concat(v.errMsg); }).join('\\n')); },\r\n    _a[ErrorType.CustomError] = function (errMsg) { return errMsg; },\r\n    _a);\r\n/** @internal */\r\nfunction stringify(value) {\r\n    if (typeof value === 'string') {\r\n        var output = JSON.stringify(value);\r\n        return \"'\" + output.substr(1, output.length - 2) + \"'\";\r\n    }\r\n    return JSON.stringify(value);\r\n}\n\n/** @internal */\r\nvar ValidateResultError = /** @class */ (function () {\r\n    function ValidateResultError(error) {\r\n        this.isSucc = false;\r\n        this.error = error;\r\n    }\r\n    Object.defineProperty(ValidateResultError.prototype, \"errMsg\", {\r\n        get: function () {\r\n            return ValidateResultError.getErrMsg(this.error);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ValidateResultError.getErrMsg = function (error) {\r\n        var _a;\r\n        var errMsg = ErrorMsg[error.type].apply(ErrorMsg, error.params);\r\n        if ((_a = error.inner) === null || _a === void 0 ? void 0 : _a.property.length) {\r\n            return \"Property `\".concat(error.inner.property.join('.'), \"`: \").concat(errMsg);\r\n        }\r\n        else {\r\n            return errMsg;\r\n        }\r\n    };\r\n    return ValidateResultError;\r\n}());\r\n/** @internal  */\r\nvar ValidateResultUtil = /** @class */ (function () {\r\n    function ValidateResultUtil() {\r\n    }\r\n    ValidateResultUtil.error = function (type) {\r\n        var params = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            params[_i - 1] = arguments[_i];\r\n        }\r\n        return new ValidateResultError({\r\n            type: type,\r\n            params: params\r\n        });\r\n    };\r\n    ValidateResultUtil.innerError = function (property, value, schema, error) {\r\n        var _a;\r\n        if (error.error.inner) {\r\n            if (typeof property === 'string') {\r\n                error.error.inner.property.unshift(property);\r\n            }\r\n            else {\r\n                (_a = error.error.inner.property).unshift.apply(_a, property);\r\n            }\r\n        }\r\n        else {\r\n            error.error.inner = {\r\n                property: typeof property === 'string' ? [property] : property,\r\n                value: value,\r\n                schema: schema\r\n            };\r\n        }\r\n        return error;\r\n    };\r\n    ValidateResultUtil.succ = { isSucc: true };\r\n    return ValidateResultUtil;\r\n}());\n\nvar typedArrays = {\r\n    Int8Array: Int8Array,\r\n    Int16Array: Int16Array,\r\n    Int32Array: Int32Array,\r\n    BigInt64Array: typeof BigInt64Array !== 'undefined' ? BigInt64Array : undefined,\r\n    Uint8Array: Uint8Array,\r\n    Uint16Array: Uint16Array,\r\n    Uint32Array: Uint32Array,\r\n    BigUint64Array: typeof BigUint64Array !== 'undefined' ? BigUint64Array : undefined,\r\n    Float32Array: Float32Array,\r\n    Float64Array: Float64Array\r\n};\r\n/**\r\n * TSBuffer Schema Validator\r\n * @public\r\n */\r\nvar TSBufferValidator = /** @class */ (function () {\r\n    function TSBufferValidator(proto, options) {\r\n        /**\r\n         * Default options\r\n         */\r\n        this.options = {\r\n            excessPropertyChecks: true,\r\n            strictNullChecks: false,\r\n            cloneProto: true\r\n        };\r\n        if (options) {\r\n            this.options = tslib.__assign(tslib.__assign({}, this.options), options);\r\n        }\r\n        this.proto = this.options.cloneProto ? Object.merge({}, proto) : proto;\r\n        this.protoHelper = new ProtoHelper(this.proto);\r\n    }\r\n    /**\r\n     * Validate whether the value is valid to the schema\r\n     * @param value - Value to be validated.\r\n     * @param schemaId - Schema or schema ID.\r\n     * For example, the schema ID for type `Test` in `a/b.ts` may be `a/b/Test`.\r\n     */\r\n    TSBufferValidator.prototype.validate = function (value, schemaOrId, options) {\r\n        var _a, _b;\r\n        var schema;\r\n        var schemaId;\r\n        // Get schema\r\n        if (typeof schemaOrId === 'string') {\r\n            schemaId = schemaOrId;\r\n            schema = this.proto[schemaId];\r\n            if (!schema) {\r\n                throw new Error(\"Cannot find schema: \".concat(schemaId));\r\n            }\r\n        }\r\n        else {\r\n            schema = schemaOrId;\r\n        }\r\n        // Merge default options\r\n        return this._validate(value, schema, tslib.__assign(tslib.__assign({}, options), { excessPropertyChecks: (_a = options === null || options === void 0 ? void 0 : options.excessPropertyChecks) !== null && _a !== void 0 ? _a : this.options.excessPropertyChecks, strictNullChecks: (_b = options === null || options === void 0 ? void 0 : options.strictNullChecks) !== null && _b !== void 0 ? _b : this.options.strictNullChecks }));\r\n    };\r\n    TSBufferValidator.prototype._validate = function (value, schema, options) {\r\n        var _a;\r\n        var vRes;\r\n        // Validate\r\n        switch (schema.type) {\r\n            case tsbufferSchema.SchemaType.Boolean:\r\n                vRes = this._validateBooleanType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Number:\r\n                vRes = this._validateNumberType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.String:\r\n                vRes = this._validateStringType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Array:\r\n                vRes = this._validateArrayType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Tuple:\r\n                vRes = this._validateTupleType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Enum:\r\n                vRes = this._validateEnumType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Any:\r\n                vRes = this._validateAnyType(value);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Literal:\r\n                vRes = this._validateLiteralType(value, schema, (_a = options === null || options === void 0 ? void 0 : options.strictNullChecks) !== null && _a !== void 0 ? _a : this.options.strictNullChecks);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Object:\r\n                vRes = this._validateObjectType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Interface:\r\n                vRes = this._validateInterfaceType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n                vRes = this._validateBufferType(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.IndexedAccess:\r\n            case tsbufferSchema.SchemaType.Reference:\r\n            case tsbufferSchema.SchemaType.Keyof:\r\n                vRes = this._validateReferenceType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Union:\r\n                vRes = this._validateUnionType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Intersection:\r\n                vRes = this._validateIntersectionType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n                vRes = this._validateMappedType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Date:\r\n                vRes = this._validateDateType(value);\r\n                break;\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                vRes = this._validateNonNullableType(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                var res = schema.validate(value);\r\n                vRes = res.isSucc ? ValidateResultUtil.succ : ValidateResultUtil.error(ErrorType.CustomError, res.errMsg);\r\n                break;\r\n            // 错误的type\r\n            default:\r\n                // @ts-expect-error\r\n                throw new Error(\"Unsupported schema type: \".concat(schema.type));\r\n        }\r\n        // prune\r\n        if (options === null || options === void 0 ? void 0 : options.prune) {\r\n            // don't need prune, return original value\r\n            if (options.prune.output === undefined) {\r\n                options.prune.output = value;\r\n            }\r\n            // output to parent\r\n            if (options.prune.parent) {\r\n                options.prune.parent.value[options.prune.parent.key] = options.prune.output;\r\n            }\r\n        }\r\n        return vRes;\r\n    };\r\n    /**\r\n     * 修剪 Object，移除 Schema 中未定义的 Key\r\n     * 需要确保 value 类型合法\r\n     * @param value - value to be validated\r\n     * @param schemaOrId -Schema or schema ID.\r\n     * @returns Validate result and pruned value. if validate failed, `pruneOutput` would be undefined.\r\n     */\r\n    TSBufferValidator.prototype.prune = function (value, schemaOrId, options) {\r\n        var _a;\r\n        var schema = typeof schemaOrId === 'string' ? this.proto[schemaOrId] : schemaOrId;\r\n        if (!schema) {\r\n            throw new Error('Cannot find schema: ' + schemaOrId);\r\n        }\r\n        var prune = {};\r\n        var vRes = this._validate(value, schema, tslib.__assign(tslib.__assign({}, options), { prune: prune, excessPropertyChecks: false, strictNullChecks: (_a = options === null || options === void 0 ? void 0 : options.strictNullChecks) !== null && _a !== void 0 ? _a : this.options.strictNullChecks }));\r\n        if (vRes.isSucc) {\r\n            vRes.pruneOutput = prune.output;\r\n        }\r\n        return vRes;\r\n    };\r\n    TSBufferValidator.prototype._validateBooleanType = function (value, schema) {\r\n        var type = this._getTypeof(value);\r\n        if (type === 'boolean') {\r\n            return ValidateResultUtil.succ;\r\n        }\r\n        else {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, 'boolean', type);\r\n        }\r\n    };\r\n    TSBufferValidator.prototype._validateNumberType = function (value, schema) {\r\n        // 默认为double\r\n        var scalarType = schema.scalarType || 'double';\r\n        // Wrong Type\r\n        var type = this._getTypeof(value);\r\n        var rightType = scalarType.indexOf('big') > -1 ? 'bigint' : 'number';\r\n        if (type !== rightType) {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, rightType, type);\r\n        }\r\n        // scalarType类型检测\r\n        // 整形却为小数\r\n        if (scalarType !== 'double' && type === 'number' && !Number.isInteger(value)) {\r\n            return ValidateResultUtil.error(ErrorType.InvalidScalarType, value, scalarType);\r\n        }\r\n        // 无符号整形却为负数\r\n        if (scalarType.indexOf('uint') > -1 && value < 0) {\r\n            return ValidateResultUtil.error(ErrorType.InvalidScalarType, value, scalarType);\r\n        }\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._validateStringType = function (value, schema) {\r\n        var type = this._getTypeof(value);\r\n        return type === 'string' ? ValidateResultUtil.succ : ValidateResultUtil.error(ErrorType.TypeError, 'string', type);\r\n    };\r\n    TSBufferValidator.prototype._validateArrayType = function (value, schema, options) {\r\n        // is Array type\r\n        var type = this._getTypeof(value);\r\n        if (type !== tsbufferSchema.SchemaType.Array) {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, tsbufferSchema.SchemaType.Array, type);\r\n        }\r\n        // prune output\r\n        var prune = options.prune;\r\n        if (prune) {\r\n            prune.output = Array.from({ length: value.length });\r\n        }\r\n        // validate elementType\r\n        for (var i = 0; i < value.length; ++i) {\r\n            var elemValidateResult = this._validate(value[i], schema.elementType, tslib.__assign(tslib.__assign({}, options), { prune: (prune === null || prune === void 0 ? void 0 : prune.output) ? {\r\n                    parent: {\r\n                        value: prune.output,\r\n                        key: i\r\n                    }\r\n                } : undefined }));\r\n            if (!elemValidateResult.isSucc) {\r\n                return ValidateResultUtil.innerError('' + i, value[i], schema.elementType, elemValidateResult);\r\n            }\r\n        }\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._validateTupleType = function (value, schema, options) {\r\n        // is Array type\r\n        var type = this._getTypeof(value);\r\n        if (type !== tsbufferSchema.SchemaType.Array) {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, tsbufferSchema.SchemaType.Array, type);\r\n        }\r\n        var prune = options.prune;\r\n        // validate length\r\n        // excessPropertyChecks 与 prune互斥\r\n        if (!prune && options.excessPropertyChecks && value.length > schema.elementTypes.length) {\r\n            return ValidateResultUtil.error(ErrorType.TupleOverLength, value.length, schema.elementTypes.length);\r\n        }\r\n        // prune output\r\n        if (prune) {\r\n            prune.output = Array.from({ length: Math.min(value.length, schema.elementTypes.length) });\r\n        }\r\n        // validate elementType\r\n        for (var i = 0; i < schema.elementTypes.length; ++i) {\r\n            // MissingRequiredProperty: NotOptional && is undefined\r\n            if (value[i] === undefined || value[i] === null && !options.strictNullChecks) {\r\n                var canBeNull = this._canBeNull(schema.elementTypes[i]);\r\n                var canBeUndefined = schema.optionalStartIndex !== undefined && i >= schema.optionalStartIndex || this._canBeUndefined(schema.elementTypes[i]);\r\n                var isOptional = canBeUndefined || !options.strictNullChecks && canBeNull;\r\n                // skip undefined property\r\n                if (isOptional) {\r\n                    // Prune null & undefined->null\r\n                    if (prune === null || prune === void 0 ? void 0 : prune.output) {\r\n                        if (value[i] === null && canBeNull\r\n                            || value[i] === undefined && !canBeUndefined && canBeNull) {\r\n                            prune.output[i] = null;\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                else {\r\n                    return ValidateResultUtil.error(ErrorType.MissingRequiredProperty, i);\r\n                }\r\n            }\r\n            // element type check\r\n            var elemValidateResult = this._validate(value[i], schema.elementTypes[i], {\r\n                prune: (prune === null || prune === void 0 ? void 0 : prune.output) ? {\r\n                    parent: {\r\n                        value: prune.output,\r\n                        key: i\r\n                    }\r\n                } : undefined,\r\n                strictNullChecks: options.strictNullChecks,\r\n                excessPropertyChecks: options.excessPropertyChecks\r\n            });\r\n            if (!elemValidateResult.isSucc) {\r\n                return ValidateResultUtil.innerError('' + i, value[i], schema.elementTypes[i], elemValidateResult);\r\n            }\r\n        }\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._canBeUndefined = function (schema) {\r\n        var _this = this;\r\n        if (schema.type === tsbufferSchema.SchemaType.Union) {\r\n            return schema.members.some(function (v) { return _this._canBeUndefined(v.type); });\r\n        }\r\n        if (schema.type === tsbufferSchema.SchemaType.Literal && schema.literal === undefined) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    TSBufferValidator.prototype._canBeNull = function (schema) {\r\n        var _this = this;\r\n        if (schema.type === tsbufferSchema.SchemaType.Union) {\r\n            return schema.members.some(function (v) { return _this._canBeNull(v.type); });\r\n        }\r\n        if (schema.type === tsbufferSchema.SchemaType.Literal && schema.literal === null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    TSBufferValidator.prototype._validateEnumType = function (value, schema) {\r\n        // must be string or number\r\n        var type = this._getTypeof(value);\r\n        if (type !== 'string' && type !== 'number') {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, 'string | number', type);\r\n        }\r\n        // 有值与预设相同\r\n        if (schema.members.some(function (v) { return v.value === value; })) {\r\n            return ValidateResultUtil.succ;\r\n        }\r\n        else {\r\n            return ValidateResultUtil.error(ErrorType.InvalidEnumValue, value);\r\n        }\r\n    };\r\n    TSBufferValidator.prototype._validateAnyType = function (value) {\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._validateLiteralType = function (value, schema, strictNullChecks) {\r\n        // 非strictNullChecks严格模式，null undefined同等对待\r\n        if (!strictNullChecks && (schema.literal === null || schema.literal === undefined)) {\r\n            return value === null || value === undefined ?\r\n                ValidateResultUtil.succ\r\n                : ValidateResultUtil.error(ErrorType.InvalidLiteralValue, schema.literal, value);\r\n        }\r\n        return value === schema.literal ?\r\n            ValidateResultUtil.succ\r\n            : ValidateResultUtil.error(ErrorType.InvalidLiteralValue, schema.literal, value);\r\n    };\r\n    TSBufferValidator.prototype._validateObjectType = function (value, schema) {\r\n        var type = this._getTypeof(value);\r\n        return type === 'Object' || type === 'Array' ? ValidateResultUtil.succ : ValidateResultUtil.error(ErrorType.TypeError, 'Object', type);\r\n    };\r\n    TSBufferValidator.prototype._validateInterfaceType = function (value, schema, options) {\r\n        var type = this._getTypeof(value);\r\n        if (type !== 'Object') {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, 'Object', type);\r\n        }\r\n        // 先展平\r\n        var flatSchema = this.protoHelper.getFlatInterfaceSchema(schema);\r\n        // From union or intersecton type\r\n        if (options.unionProperties) {\r\n            flatSchema = this.protoHelper.applyUnionProperties(flatSchema, options.unionProperties);\r\n        }\r\n        return this._validateFlatInterface(value, flatSchema, options);\r\n    };\r\n    TSBufferValidator.prototype._validateMappedType = function (value, schema, options) {\r\n        var parsed = this.protoHelper.parseMappedType(schema);\r\n        if (parsed.type === tsbufferSchema.SchemaType.Interface) {\r\n            return this._validateInterfaceType(value, schema, options);\r\n        }\r\n        else if (parsed.type === tsbufferSchema.SchemaType.Union) {\r\n            return this._validateUnionType(value, parsed, options);\r\n        }\r\n        else if (parsed.type === tsbufferSchema.SchemaType.Intersection) {\r\n            return this._validateIntersectionType(value, parsed, options);\r\n        }\r\n        // @ts-expect-error\r\n        throw new Error(\"Invalid \".concat(schema.type, \" target type: \").concat(parsed.type));\r\n    };\r\n    TSBufferValidator.prototype._validateFlatInterface = function (value, schema, options) {\r\n        // interfaceSignature强制了key必须是数字的情况\r\n        if (schema.indexSignature && schema.indexSignature.keyType === tsbufferSchema.SchemaType.Number) {\r\n            for (var key in value) {\r\n                if (!this._isNumberKey(key)) {\r\n                    return ValidateResultUtil.error(ErrorType.InvalidNumberKey, key);\r\n                }\r\n            }\r\n        }\r\n        var prune = options.prune;\r\n        if (prune) {\r\n            prune.output = {};\r\n        }\r\n        // Excess property check (与prune互斥)\r\n        if (!prune && options.excessPropertyChecks && !schema.indexSignature) {\r\n            var validProperties_1 = schema.properties.map(function (v) { return v.name; });\r\n            var firstExcessProperty = Object.keys(value).find(function (v) { return validProperties_1.indexOf(v) === -1; });\r\n            if (firstExcessProperty) {\r\n                return ValidateResultUtil.error(ErrorType.ExcessProperty, firstExcessProperty);\r\n            }\r\n        }\r\n        // 校验properties\r\n        if (schema.properties) {\r\n            for (var _i = 0, _a = schema.properties; _i < _a.length; _i++) {\r\n                var property = _a[_i];\r\n                // MissingRequiredProperty: is undefined && !isOptional\r\n                if (value[property.name] === undefined || value[property.name] === null && !options.strictNullChecks) {\r\n                    var canBeNull = this._canBeNull(property.type);\r\n                    var canBeUndefined = property.optional || this._canBeUndefined(property.type);\r\n                    var isOptional = canBeUndefined || !options.strictNullChecks && canBeNull;\r\n                    // skip undefined optional property\r\n                    if (isOptional) {\r\n                        // Prune null & undefined->null\r\n                        if (prune === null || prune === void 0 ? void 0 : prune.output) {\r\n                            if (value[property.name] === null && canBeNull\r\n                                || value[property.name] === undefined && !canBeUndefined && canBeNull) {\r\n                                prune.output[property.name] = null;\r\n                            }\r\n                        }\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        return ValidateResultUtil.error(ErrorType.MissingRequiredProperty, property.name);\r\n                    }\r\n                }\r\n                // property本身验证\r\n                var vRes = this._validate(value[property.name], property.type, {\r\n                    prune: (prune === null || prune === void 0 ? void 0 : prune.output) && property.id > -1 ? {\r\n                        parent: {\r\n                            value: prune.output,\r\n                            key: property.name\r\n                        }\r\n                    } : undefined,\r\n                    strictNullChecks: options.strictNullChecks,\r\n                    excessPropertyChecks: options.excessPropertyChecks\r\n                });\r\n                if (!vRes.isSucc) {\r\n                    return ValidateResultUtil.innerError(property.name, value[property.name], property.type, vRes);\r\n                }\r\n            }\r\n        }\r\n        // 检测indexSignature\r\n        if (schema.indexSignature) {\r\n            for (var key in value) {\r\n                // only prune is (property is pruned already)\r\n                // let memberPrune: ValidatePruneOptions | undefined = schema.properties.some(v => v.name === key) ? undefined : {};\r\n                // validate each field\r\n                var vRes = this._validate(value[key], schema.indexSignature.type, {\r\n                    prune: (prune === null || prune === void 0 ? void 0 : prune.output) ? {\r\n                        parent: {\r\n                            value: prune.output,\r\n                            key: key\r\n                        }\r\n                    } : undefined,\r\n                    strictNullChecks: options.strictNullChecks,\r\n                    excessPropertyChecks: options.excessPropertyChecks\r\n                });\r\n                if (!vRes.isSucc) {\r\n                    return ValidateResultUtil.innerError(key, value[key], schema.indexSignature.type, vRes);\r\n                }\r\n            }\r\n        }\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._validateBufferType = function (value, schema) {\r\n        var _a, _b;\r\n        var type = this._getTypeof(value);\r\n        if (type !== 'Object') {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, schema.arrayType || 'ArrayBuffer', type);\r\n        }\r\n        else if (schema.arrayType) {\r\n            var typeArrayClass = typedArrays[schema.arrayType];\r\n            if (!typeArrayClass) {\r\n                throw new Error(\"Error TypedArray type: \".concat(schema.arrayType));\r\n            }\r\n            return value instanceof typeArrayClass ? ValidateResultUtil.succ : ValidateResultUtil.error(ErrorType.TypeError, schema.arrayType, (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name);\r\n        }\r\n        else {\r\n            return value instanceof ArrayBuffer ? ValidateResultUtil.succ : ValidateResultUtil.error(ErrorType.TypeError, 'ArrayBuffer', (_b = value === null || value === void 0 ? void 0 : value.constructor) === null || _b === void 0 ? void 0 : _b.name);\r\n        }\r\n    };\r\n    TSBufferValidator.prototype._validateReferenceType = function (value, schema, options) {\r\n        return this._validate(value, this.protoHelper.parseReference(schema), options);\r\n    };\r\n    TSBufferValidator.prototype._validateUnionType = function (value, schema, options) {\r\n        var _this = this;\r\n        options.unionProperties = options.unionProperties || this.protoHelper.getUnionProperties(schema);\r\n        var isObjectPrune = false;\r\n        var prune = options.prune;\r\n        if (prune && value && Object.getPrototypeOf(value) === Object.prototype) {\r\n            isObjectPrune = true;\r\n            prune.output = {};\r\n        }\r\n        // 有一成功则成功\r\n        var isSomeSucc = false;\r\n        var memberErrors = [];\r\n        for (var i = 0; i < schema.members.length; ++i) {\r\n            var member = schema.members[i];\r\n            var memberType = this.protoHelper.isTypeReference(member.type) ? this.protoHelper.parseReference(member.type) : member.type;\r\n            var memberPrune = prune ? {} : undefined;\r\n            var vRes = this._validate(value, memberType, tslib.__assign(tslib.__assign({}, options), { prune: memberPrune }));\r\n            if (vRes.isSucc) {\r\n                isSomeSucc = true;\r\n                // if prune object: must prune all members\r\n                if (isObjectPrune) {\r\n                    prune.output = tslib.__assign(tslib.__assign({}, prune.output), memberPrune.output);\r\n                }\r\n                // not prune object: stop checking after 1st member matched\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                memberErrors.push(vRes);\r\n            }\r\n        }\r\n        // 有一成功则成功;\r\n        if (isSomeSucc) {\r\n            return ValidateResultUtil.succ;\r\n        }\r\n        // 全部失败，则失败\r\n        else {\r\n            // All member error is the same, return the first\r\n            var msg0_1 = memberErrors[0].errMsg;\r\n            if (memberErrors.every(function (v) { return v.errMsg === msg0_1; })) {\r\n                return memberErrors[0];\r\n            }\r\n            // mutual exclusion: return the only one\r\n            var nonLiteralErrors = memberErrors.filter(function (v) { return v.error.type !== ErrorType.InvalidLiteralValue; });\r\n            if (nonLiteralErrors.length === 1) {\r\n                return nonLiteralErrors[0];\r\n            }\r\n            // All member error without inner: show simple msg\r\n            if (memberErrors.every(function (v) { return !v.error.inner && (v.error.type === ErrorType.TypeError || v.error.type === ErrorType.InvalidLiteralValue); })) {\r\n                var valueType = this._getTypeof(value);\r\n                var expectedTypes = memberErrors.map(function (v) { return v.error.type === ErrorType.TypeError ? v.error.params[0] : _this._getTypeof(v.error.params[0]); }).distinct();\r\n                // Expected type A|B|C, actually type D\r\n                if (expectedTypes.indexOf(valueType) === -1) {\r\n                    return ValidateResultUtil.error(ErrorType.TypeError, expectedTypes.join(' | '), this._getTypeof(value));\r\n                }\r\n                // `'D'` is not matched to `'A'|'B'|'C'`\r\n                if (valueType !== 'Object' && valueType !== tsbufferSchema.SchemaType.Array) {\r\n                    var types = memberErrors.map(function (v) { return v.error.type === ErrorType.TypeError ? v.error.params[0] : stringify(v.error.params[0]); }).distinct();\r\n                    return ValidateResultUtil.error(ErrorType.UnionTypesNotMatch, value, types);\r\n                }\r\n            }\r\n            // other errors\r\n            return ValidateResultUtil.error(ErrorType.UnionMembersNotMatch, memberErrors);\r\n        }\r\n    };\r\n    TSBufferValidator.prototype._validateIntersectionType = function (value, schema, options) {\r\n        options.unionProperties = options.unionProperties || this.protoHelper.getUnionProperties(schema);\r\n        var isObjectPrune = false;\r\n        var prune = options.prune;\r\n        if (prune && value && Object.getPrototypeOf(value) === Object.prototype) {\r\n            prune.output = {};\r\n            isObjectPrune = true;\r\n        }\r\n        // 有一失败则失败\r\n        for (var i = 0, len = schema.members.length; i < len; ++i) {\r\n            // 验证member\r\n            var memberType = schema.members[i].type;\r\n            memberType = this.protoHelper.isTypeReference(memberType) ? this.protoHelper.parseReference(memberType) : memberType;\r\n            var memberPrune = prune ? {} : undefined;\r\n            var vRes = this._validate(value, memberType, tslib.__assign(tslib.__assign({}, options), { prune: memberPrune }));\r\n            // 有一失败则失败\r\n            if (!vRes.isSucc) {\r\n                return vRes;\r\n            }\r\n            if (isObjectPrune) {\r\n                prune.output = tslib.__assign(tslib.__assign({}, prune.output), memberPrune.output);\r\n            }\r\n        }\r\n        // 全成功则成功\r\n        return ValidateResultUtil.succ;\r\n    };\r\n    TSBufferValidator.prototype._validateDateType = function (value) {\r\n        if (value instanceof Date) {\r\n            return ValidateResultUtil.succ;\r\n        }\r\n        else {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, 'Date', this._getTypeof(value));\r\n        }\r\n    };\r\n    TSBufferValidator.prototype._validateNonNullableType = function (value, schema, options) {\r\n        var type = this._getTypeof(value);\r\n        if ((type === 'null' || type === 'undefined') && schema.target.type !== 'Any') {\r\n            return ValidateResultUtil.error(ErrorType.TypeError, 'NonNullable', type);\r\n        }\r\n        return this._validate(value, schema.target, options);\r\n    };\r\n    TSBufferValidator.prototype._isNumberKey = function (key) {\r\n        var int = parseInt(key);\r\n        return !(isNaN(int) || ('' + int) !== key);\r\n    };\r\n    TSBufferValidator.prototype._getTypeof = function (value) {\r\n        var type = typeof value;\r\n        if (type === 'object') {\r\n            if (value === null) {\r\n                return 'null';\r\n            }\r\n            else if (Array.isArray(value)) {\r\n                return tsbufferSchema.SchemaType.Array;\r\n            }\r\n            else {\r\n                return 'Object';\r\n            }\r\n        }\r\n        return type;\r\n    };\r\n    return TSBufferValidator;\r\n}());\n\nexports.ProtoHelper = ProtoHelper;\nexports.TSBufferValidator = TSBufferValidator;\n"]}