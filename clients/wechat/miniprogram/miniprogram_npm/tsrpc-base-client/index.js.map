{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * TSRPC Base Client v2.1.10\n * -----------------------------------------\n * Copyright (c) Kingworks Corporation.\n * MIT License\n * https://github.com/k8w/tsrpc-base-client\n */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('k8w-extend-native');\nvar tslib = require('tslib');\nvar tsbuffer = require('tsbuffer');\nvar tsrpcProto = require('tsrpc-proto');\nvar tsbufferSchema = require('tsbuffer-schema');\n\n/**\r\n * An auto-increment counter\r\n */\r\nvar Counter = /** @class */ (function () {\r\n    function Counter(min, max) {\r\n        if (min === void 0) { min = 1; }\r\n        if (max === void 0) { max = Number.MAX_SAFE_INTEGER; }\r\n        this._min = min;\r\n        this._max = max;\r\n        this._last = max;\r\n    }\r\n    /**\r\n     * Reset the counter, makes `getNext()` restart from `0`\r\n     */\r\n    Counter.prototype.reset = function () {\r\n        this._last = this._max;\r\n    };\r\n    /**\r\n     * Get next counter value, and auto increment `1`\r\n     * @param notInc - Just get the next possible value, not actually increasing the sequence\r\n     */\r\n    Counter.prototype.getNext = function (notInc) {\r\n        return this._last >= this._max ? (this._last = this._min) : (notInc ? this._last : ++this._last);\r\n    };\r\n    Object.defineProperty(Counter.prototype, \"last\", {\r\n        /**\r\n         * Last return of `getNext()`\r\n         */\r\n        get: function () {\r\n            return this._last;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Counter;\r\n}());\n\n/**\r\n * A `Flow` is consists of many `FlowNode`, which is function with the same input and output (like pipeline).\r\n *\r\n * @remarks\r\n * `Flow` is like a hook or event, executed at a specific time.\r\n * The difference to event is it can be used to **interrupt** an action, by return `undefined` or `null` in a node.\r\n */\r\nvar Flow = /** @class */ (function () {\r\n    function Flow() {\r\n        /**\r\n         * All node functions, if you want to adjust the sort you can modify this.\r\n         */\r\n        this.nodes = [];\r\n        /**\r\n         * Event when error throwed from a `FlowNode` function.\r\n         * By default, it does nothing except print a `Uncaught FlowError` error log.\r\n         * @param e\r\n         * @param last\r\n         * @param input\r\n         * @param logger\r\n         */\r\n        this.onError = function (e, last, input, logger) {\r\n            logger === null || logger === void 0 ? void 0 : logger.error('Uncaught FlowError:', e);\r\n        };\r\n    }\r\n    /**\r\n     * Execute all node function one by one, the previous output is the next input,\r\n     * until the last output would be return to the caller.\r\n     *\r\n     * @remarks\r\n     * If any node function return `null | undefined`, or throws an error,\r\n     * the latter node functions would not be executed.\r\n     * And it would return `null | undefined` immediately to the caller,\r\n     * which tell the caller it means a interruption,\r\n     * to let the caller stop latter behaviours.\r\n     *\r\n     * @param input The input of the first `FlowNode`\r\n     * @param logger Logger to print log, `undefined` means to hide all log.\r\n     * @returns\r\n     */\r\n    Flow.prototype.exec = function (input, logger) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var res, i, e_1;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        res = input;\r\n                        i = 0;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < this.nodes.length)) return [3 /*break*/, 7];\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        return [4 /*yield*/, this.nodes[i](res)];\r\n                    case 3:\r\n                        res = _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_1 = _a.sent();\r\n                        this.onError(e_1, res, input, logger);\r\n                        return [2 /*return*/, undefined];\r\n                    case 5:\r\n                        // Return 非true 表示不继续后续流程 立即中止\r\n                        if (res === null || res === undefined) {\r\n                            return [2 /*return*/, res];\r\n                        }\r\n                        _a.label = 6;\r\n                    case 6:\r\n                        ++i;\r\n                        return [3 /*break*/, 1];\r\n                    case 7: return [2 /*return*/, res];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Append a node function to the last\r\n     * @param node\r\n     * @returns\r\n     */\r\n    Flow.prototype.push = function (node) {\r\n        this.nodes.push(node);\r\n        return node;\r\n    };\r\n    /**\r\n     * Remove a node function\r\n     * @param node\r\n     * @returns\r\n     */\r\n    Flow.prototype.remove = function (node) {\r\n        return this.nodes.remove(function (v) { return v === node; });\r\n    };\r\n    return Flow;\r\n}());\n\nfunction getCustomObjectIdTypes(classObjectId) {\r\n    var output = {};\r\n    // string\r\n    if (classObjectId === String) {\r\n        output['?mongodb/ObjectId'] = {\r\n            type: tsbufferSchema.SchemaType.Custom,\r\n            validate: function (value) {\r\n                if (typeof value !== 'string') {\r\n                    return { isSucc: false, errMsg: \"Expected type to be `string`, actually `\".concat(typeof value, \"`.\") };\r\n                }\r\n                if (!/[0-9a-fA-F]{24}/.test(value)) {\r\n                    return { isSucc: false, errMsg: 'ObjectId must be a string of 24 hex characters' };\r\n                }\r\n                return { isSucc: true };\r\n            },\r\n            encode: function (value) {\r\n                return new Uint8Array(Array.from({ length: 12 }, function (_, i) { return Number.parseInt('0x' + value.substr(i * 2, 2)); }));\r\n            },\r\n            decode: function (buf) {\r\n                return Array.from(buf, function (v) {\r\n                    var str = v.toString(16);\r\n                    if (str.length === 1) {\r\n                        str = '0' + str;\r\n                    }\r\n                    return str;\r\n                }).join('');\r\n            }\r\n        };\r\n    }\r\n    // ObjectId\r\n    else {\r\n        output['?mongodb/ObjectId'] = {\r\n            type: tsbufferSchema.SchemaType.Custom,\r\n            validate: function (value) { return (value instanceof classObjectId) ?\r\n                { isSucc: true } :\r\n                { isSucc: false, errMsg: \"Expected to be instance of `ObjectId`, actually not.\" }; },\r\n            encode: function (value) { return new Uint8Array(value.id); },\r\n            decode: function (buf) { return new classObjectId(buf); },\r\n            decodeJSON: function (json) { return new classObjectId(json); }\r\n        };\r\n    }\r\n    output['?mongodb/ObjectID'] = output['?mongodb/ObjectId'];\r\n    output['?bson/ObjectId'] = output['?mongodb/ObjectId'];\r\n    output['?bson/ObjectID'] = output['?mongodb/ObjectId'];\r\n    return output;\r\n}\n\n/**\r\n * A manager for TSRPC receiving messages\r\n */\r\nvar MsgHandlerManager = /** @class */ (function () {\r\n    function MsgHandlerManager() {\r\n        this._handlers = {};\r\n    }\r\n    /**\r\n     * Execute all handlers parallelly\r\n     * @returns handlers count\r\n     */\r\n    MsgHandlerManager.prototype.forEachHandler = function (msgName, logger) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var handlers = this._handlers[msgName];\r\n        if (!handlers) {\r\n            return [];\r\n        }\r\n        var output = [];\r\n        for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\r\n            var handler = handlers_1[_a];\r\n            try {\r\n                output.push(handler.apply(void 0, args));\r\n            }\r\n            catch (e) {\r\n                logger === null || logger === void 0 ? void 0 : logger.error('[MsgHandlerError]', e);\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n    /**\r\n     * Add message handler, duplicate handlers to the same `msgName` would be ignored.\r\n     * @param msgName\r\n     * @param handler\r\n     * @returns\r\n     */\r\n    MsgHandlerManager.prototype.addHandler = function (msgName, handler) {\r\n        var handlers = this._handlers[msgName];\r\n        // 初始化Handlers\r\n        if (!handlers) {\r\n            handlers = this._handlers[msgName] = [];\r\n        }\r\n        // 防止重复监听\r\n        else if (handlers.some(function (v) { return v === handler; })) {\r\n            return;\r\n        }\r\n        handlers.push(handler);\r\n    };\r\n    /**\r\n     * Remove handler from the specific `msgName`\r\n     * @param msgName\r\n     * @param handler\r\n     * @returns\r\n     */\r\n    MsgHandlerManager.prototype.removeHandler = function (msgName, handler) {\r\n        var handlers = this._handlers[msgName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        handlers.removeOne(function (v) { return v === handler; });\r\n    };\r\n    /**\r\n     * Remove all handlers for the specific `msgName`\r\n     * @param msgName\r\n     */\r\n    MsgHandlerManager.prototype.removeAllHandlers = function (msgName) {\r\n        this._handlers[msgName] = undefined;\r\n    };\r\n    return MsgHandlerManager;\r\n}());\n\n/** A utility for generate `ServiceMap` */\r\nvar ServiceMapUtil = /** @class */ (function () {\r\n    function ServiceMapUtil() {\r\n    }\r\n    ServiceMapUtil.getServiceMap = function (proto) {\r\n        var map = {\r\n            id2Service: {},\r\n            apiName2Service: {},\r\n            msgName2Service: {}\r\n        };\r\n        for (var _i = 0, _a = proto.services; _i < _a.length; _i++) {\r\n            var v = _a[_i];\r\n            var match = v.name.match(/(.+\\/)?([^\\/]+)$/);\r\n            var path = match[1] || '';\r\n            var name_1 = match[2];\r\n            if (v.type === 'api') {\r\n                var svc = tslib.__assign(tslib.__assign({}, v), { reqSchemaId: \"\".concat(path, \"Ptl\").concat(name_1, \"/Req\").concat(name_1), resSchemaId: \"\".concat(path, \"Ptl\").concat(name_1, \"/Res\").concat(name_1) });\r\n                map.apiName2Service[v.name] = svc;\r\n                map.id2Service[v.id] = svc;\r\n            }\r\n            else {\r\n                var svc = tslib.__assign(tslib.__assign({}, v), { msgSchemaId: \"\".concat(path, \"Msg\").concat(name_1, \"/Msg\").concat(name_1) });\r\n                map.msgName2Service[v.name] = svc;\r\n                map.id2Service[v.id] = svc;\r\n            }\r\n        }\r\n        return map;\r\n    };\r\n    return ServiceMapUtil;\r\n}());\n\nvar TransportDataUtil = /** @class */ (function () {\r\n    function TransportDataUtil() {\r\n    }\r\n    Object.defineProperty(TransportDataUtil, \"tsbuffer\", {\r\n        get: function () {\r\n            if (!this._tsbuffer) {\r\n                this._tsbuffer = new tsbuffer.TSBuffer(tsrpcProto.TransportDataProto);\r\n            }\r\n            return this._tsbuffer;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    TransportDataUtil.encodeClientMsg = function (tsbuffer, service, msg, type, connType) {\r\n        if (type === 'buffer') {\r\n            var op = tsbuffer.encode(msg, service.msgSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var serverInputData = {\r\n                serviceId: service.id,\r\n                buffer: op.buf\r\n            };\r\n            var opOut = this.tsbuffer.encode(serverInputData, 'ServerInputData');\r\n            return opOut.isSucc ? { isSucc: true, output: opOut.buf } : { isSucc: false, errMsg: opOut.errMsg };\r\n        }\r\n        else {\r\n            var op = tsbuffer.encodeJSON(msg, service.msgSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var json = connType === 'SHORT' ? op.json : [service.name, op.json];\r\n            return { isSucc: true, output: type === 'json' ? json : JSON.stringify(json) };\r\n        }\r\n    };\r\n    TransportDataUtil.encodeApiReq = function (tsbuffer, service, req, type, sn) {\r\n        if (type === 'buffer') {\r\n            var op = tsbuffer.encode(req, service.reqSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var serverInputData = {\r\n                serviceId: service.id,\r\n                buffer: op.buf,\r\n                sn: sn\r\n            };\r\n            var opOut = this.tsbuffer.encode(serverInputData, 'ServerInputData');\r\n            return opOut.isSucc ? { isSucc: true, output: opOut.buf } : { isSucc: false, errMsg: opOut.errMsg };\r\n        }\r\n        else {\r\n            var op = tsbuffer.encodeJSON(req, service.reqSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var json = sn === undefined ? op.json : [service.name, op.json, sn];\r\n            return { isSucc: true, output: type === 'json' ? json : JSON.stringify(json) };\r\n        }\r\n    };\r\n    TransportDataUtil.encodeServerMsg = function (tsbuffer, service, msg, type, connType) {\r\n        if (type === 'buffer') {\r\n            var op = tsbuffer.encode(msg, service.msgSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var serverOutputData = {\r\n                serviceId: service.id,\r\n                buffer: op.buf\r\n            };\r\n            var opOut = this.tsbuffer.encode(serverOutputData, 'ServerOutputData');\r\n            return opOut.isSucc ? { isSucc: true, output: opOut.buf } : { isSucc: false, errMsg: opOut.errMsg };\r\n        }\r\n        else {\r\n            var op = tsbuffer.encodeJSON(msg, service.msgSchemaId);\r\n            if (!op.isSucc) {\r\n                return op;\r\n            }\r\n            var json = connType === 'SHORT' ? op.json : [service.name, op.json];\r\n            return { isSucc: true, output: type === 'json' ? json : JSON.stringify(json) };\r\n        }\r\n    };\r\n    TransportDataUtil.parseServerOutout = function (tsbuffer, serviceMap, data, serviceId) {\r\n        if (data instanceof Uint8Array) {\r\n            var opServerOutputData = this.tsbuffer.decode(data, 'ServerOutputData');\r\n            if (!opServerOutputData.isSucc) {\r\n                return opServerOutputData;\r\n            }\r\n            var serverOutputData = opServerOutputData.value;\r\n            serviceId = serviceId !== null && serviceId !== void 0 ? serviceId : serverOutputData.serviceId;\r\n            if (serviceId === undefined) {\r\n                return { isSucc: false, errMsg: \"Missing 'serviceId' in ServerOutput\" };\r\n            }\r\n            var service = serviceMap.id2Service[serviceId];\r\n            if (!service) {\r\n                return { isSucc: false, errMsg: \"Invalid service ID: \".concat(serviceId, \" (from ServerOutput)\") };\r\n            }\r\n            if (service.type === 'msg') {\r\n                if (!serverOutputData.buffer) {\r\n                    return { isSucc: false, errMsg: 'Empty msg buffer (from ServerOutput)' };\r\n                }\r\n                var opMsg = tsbuffer.decode(serverOutputData.buffer, service.msgSchemaId);\r\n                if (!opMsg.isSucc) {\r\n                    return opMsg;\r\n                }\r\n                return {\r\n                    isSucc: true,\r\n                    result: {\r\n                        type: 'msg',\r\n                        service: service,\r\n                        msg: opMsg.value\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                if (serverOutputData.error) {\r\n                    return {\r\n                        isSucc: true,\r\n                        result: {\r\n                            type: 'api',\r\n                            service: service,\r\n                            sn: serverOutputData.sn,\r\n                            ret: {\r\n                                isSucc: false,\r\n                                err: new tsrpcProto.TsrpcError(serverOutputData.error)\r\n                            }\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    if (!serverOutputData.buffer) {\r\n                        return { isSucc: false, errMsg: 'Empty API res buffer (from ServerOutput)' };\r\n                    }\r\n                    var opRes = tsbuffer.decode(serverOutputData.buffer, service.resSchemaId);\r\n                    if (!opRes.isSucc) {\r\n                        return opRes;\r\n                    }\r\n                    return {\r\n                        isSucc: true,\r\n                        result: {\r\n                            type: 'api',\r\n                            service: service,\r\n                            sn: serverOutputData.sn,\r\n                            ret: {\r\n                                isSucc: true,\r\n                                res: opRes.value,\r\n                            }\r\n                        }\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var json = void 0;\r\n            if (typeof data === 'string') {\r\n                try {\r\n                    json = JSON.parse(data);\r\n                }\r\n                catch (e) {\r\n                    return { isSucc: false, errMsg: \"Invalid input JSON: \".concat(e.message) };\r\n                }\r\n            }\r\n            else {\r\n                json = data;\r\n            }\r\n            var body = void 0;\r\n            var sn = void 0;\r\n            var service = void 0;\r\n            if (serviceId == undefined) {\r\n                if (!Array.isArray(json)) {\r\n                    return { isSucc: false, errMsg: \"Invalid server output format\" };\r\n                }\r\n                var serviceName = json[0];\r\n                body = json[1];\r\n                sn = json[2];\r\n                // 有 SN 是 Api，没 SN 是 Msg\r\n                service = sn ? serviceMap.apiName2Service[serviceName] : serviceMap.msgName2Service[serviceName];\r\n                if (!service) {\r\n                    return { isSucc: false, errMsg: \"Invalid service name: \".concat(serviceName, \" (from ServerOutputData)\") };\r\n                }\r\n            }\r\n            else {\r\n                service = serviceMap.id2Service[serviceId];\r\n                if (!service) {\r\n                    return { isSucc: false, errMsg: \"Invalid service ID: \".concat(serviceId) };\r\n                }\r\n                body = json;\r\n            }\r\n            if (service.type === 'api') {\r\n                if (body.isSucc && 'res' in body) {\r\n                    var op = tsbuffer.decodeJSON(body.res, service.resSchemaId);\r\n                    if (!op.isSucc) {\r\n                        return op;\r\n                    }\r\n                    body.res = op.value;\r\n                }\r\n                else if (body.err) {\r\n                    body.err = new tsrpcProto.TsrpcError(body.err);\r\n                }\r\n                else {\r\n                    return { isSucc: false, errMsg: \"Invalid server output format\" };\r\n                }\r\n                return {\r\n                    isSucc: true,\r\n                    result: {\r\n                        type: 'api',\r\n                        service: service,\r\n                        sn: sn,\r\n                        ret: body\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                var op = tsbuffer.decodeJSON(body, service.msgSchemaId);\r\n                if (!op.isSucc) {\r\n                    return op;\r\n                }\r\n                return {\r\n                    isSucc: true,\r\n                    result: {\r\n                        type: 'msg',\r\n                        service: service,\r\n                        msg: op.value\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    };\r\n    // 心跳包（Ping & Pong），所有开头为 0 的 Buffer，均为控制指令\r\n    TransportDataUtil.HeartbeatPacket = new Uint8Array([0]);\r\n    return TransportDataUtil;\r\n}());\n\n/**\r\n * An abstract base class for TSRPC Client,\r\n * which includes some common buffer process flows.\r\n *\r\n * @remarks\r\n * You can implement a client on a specific transportation protocol (like HTTP, WebSocket, QUIP) by extend this.\r\n *\r\n * @typeParam ServiceType - `ServiceType` from generated `proto.ts`\r\n *\r\n * @see\r\n * {@link https://github.com/k8w/tsrpc}\r\n * {@link https://github.com/k8w/tsrpc-browser}\r\n * {@link https://github.com/k8w/tsrpc-miniapp}\r\n */\r\nvar BaseClient = /** @class */ (function () {\r\n    function BaseClient(proto, options) {\r\n        this._msgHandlers = new MsgHandlerManager();\r\n        /**\r\n         * {@link Flow} to process `callApi`, `sendMsg`, buffer input/output, etc...\r\n         */\r\n        this.flows = {\r\n            // callApi\r\n            preCallApiFlow: new Flow(),\r\n            preApiReturnFlow: new Flow(),\r\n            postApiReturnFlow: new Flow(),\r\n            // sendMsg\r\n            preSendMsgFlow: new Flow(),\r\n            postSendMsgFlow: new Flow(),\r\n            preRecvMsgFlow: new Flow(),\r\n            postRecvMsgFlow: new Flow(),\r\n            // buffer\r\n            preSendDataFlow: new Flow(),\r\n            preRecvDataFlow: new Flow(),\r\n            /**\r\n             * @deprecated Please use `preSendDataFlow` instead\r\n             */\r\n            preSendBufferFlow: new Flow(),\r\n            /**\r\n             * @deprecated Please use `preRecvDataFlow` instead\r\n             */\r\n            preRecvBufferFlow: new Flow(),\r\n            // Connection Flows (Only for WebSocket)\r\n            /** Before connect to WebSocket server */\r\n            preConnectFlow: new Flow(),\r\n            /** After WebSocket connect successfully */\r\n            postConnectFlow: new Flow(),\r\n            /** After WebSocket disconnected (from connected status) */\r\n            postDisconnectFlow: new Flow(),\r\n        };\r\n        this._apiSnCounter = new Counter(1);\r\n        /**\r\n         * Pending API Requests\r\n         */\r\n        this._pendingApis = [];\r\n        /** @deprecated Please use `_onRecvData` instead */\r\n        this._onRecvBuf = this._onRecvData;\r\n        this.options = options;\r\n        this.serviceMap = ServiceMapUtil.getServiceMap(proto);\r\n        this.dataType = this.options.json ? 'text' : 'buffer';\r\n        var types = tslib.__assign({}, proto.types);\r\n        // Custom ObjectId handler\r\n        if (options.customObjectIdClass) {\r\n            types = tslib.__assign(tslib.__assign({}, types), getCustomObjectIdTypes(options.customObjectIdClass));\r\n        }\r\n        this.tsbuffer = new tsbuffer.TSBuffer(types);\r\n        this.logger = this.options.logger;\r\n        if (this.logger) {\r\n            this.logger = tsrpcProto.setLogLevel(this.logger, this.options.logLevel);\r\n        }\r\n    }\r\n    Object.defineProperty(BaseClient.prototype, \"lastSN\", {\r\n        /**\r\n         * The `SN` number of the last `callApi()`,\r\n         * which can be passed to `abort()` to abort an API request.\r\n         * @example\r\n         * ```ts\r\n         * client.callApi('xxx', { value: 'xxx' })\r\n         *   .then(ret=>{ console.log('succ', ret) });\r\n         * let lastSN = client.lastSN;\r\n         * client.abort(lastSN);\r\n         * ```\r\n         */\r\n        get: function () {\r\n            return this._apiSnCounter.last;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseClient.prototype, \"nextSN\", {\r\n        /**\r\n         * The `SN` number of the next `callApi()`,\r\n         * which can be passed to `abort()` to abort an API request.\r\n         * @example\r\n         * ```ts\r\n         * let nextSN = client.nextSN;\r\n         * client.callApi('xxx', { value: 'xxx' })\r\n         * ```\r\n         */\r\n        get: function () {\r\n            return this._apiSnCounter.getNext(true);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Send request and wait for the return\r\n     * @param apiName\r\n     * @param req - Request body\r\n     * @param options - Transport options\r\n     * @returns return a `ApiReturn`, all error (network error, business error, code exception...) is unified as `TsrpcError`.\r\n     * The promise is never rejected, so you just need to process all error in one place.\r\n     */\r\n    BaseClient.prototype.callApi = function (apiName, req, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var sn, pendingItem, promise;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                sn = this._apiSnCounter.getNext();\r\n                pendingItem = {\r\n                    sn: sn,\r\n                    abortKey: options.abortKey,\r\n                    service: this.serviceMap.apiName2Service[apiName]\r\n                };\r\n                this._pendingApis.push(pendingItem);\r\n                promise = new Promise(function (rs) { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n                    var pre, ret, preReturn;\r\n                    var _a, _b;\r\n                    return tslib.__generator(this, function (_c) {\r\n                        switch (_c.label) {\r\n                            case 0: return [4 /*yield*/, this.flows.preCallApiFlow.exec({\r\n                                    apiName: apiName,\r\n                                    req: req,\r\n                                    options: options\r\n                                }, this.logger)];\r\n                            case 1:\r\n                                pre = _c.sent();\r\n                                if (!pre || pendingItem.isAborted) {\r\n                                    this.abort(pendingItem.sn);\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                if (!pre.return) return [3 /*break*/, 2];\r\n                                ret = pre.return;\r\n                                return [3 /*break*/, 4];\r\n                            case 2: return [4 /*yield*/, this._doCallApi(pre.apiName, pre.req, pre.options, pendingItem)];\r\n                            case 3:\r\n                                // do call means it will send buffer via network\r\n                                ret = _c.sent();\r\n                                _c.label = 4;\r\n                            case 4:\r\n                                if (pendingItem.isAborted) {\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                // Log Original Return\r\n                                if (ret.isSucc) {\r\n                                    this.options.logApi && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(\"[ApiRes] #\".concat(pendingItem.sn, \" \").concat(apiName), ret.res));\r\n                                }\r\n                                else {\r\n                                    this.options.logApi && ((_b = this.logger) === null || _b === void 0 ? void 0 : _b[ret.err.type === tsrpcProto.TsrpcError.Type.ApiError ? 'log' : 'error'](\"[ApiErr] #\".concat(pendingItem.sn, \" \").concat(apiName), ret.err));\r\n                                }\r\n                                return [4 /*yield*/, this.flows.preApiReturnFlow.exec(tslib.__assign(tslib.__assign({}, pre), { return: ret }), this.logger)];\r\n                            case 5:\r\n                                preReturn = _c.sent();\r\n                                if (!preReturn) {\r\n                                    this.abort(pendingItem.sn);\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                rs(preReturn.return);\r\n                                // Post Flow\r\n                                this.flows.postApiReturnFlow.exec(preReturn, this.logger);\r\n                                return [2 /*return*/];\r\n                        }\r\n                    });\r\n                }); });\r\n                // Finally clear pendings\r\n                promise.catch().then(function () {\r\n                    _this._pendingApis.removeOne(function (v) { return v.sn === pendingItem.sn; });\r\n                });\r\n                return [2 /*return*/, promise];\r\n            });\r\n        });\r\n    };\r\n    BaseClient.prototype._doCallApi = function (apiName, req, options, pendingItem) {\r\n        var _a;\r\n        if (options === void 0) { options = {}; }\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var promise;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_b) {\r\n                this.options.logApi && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(\"[ApiReq] #\".concat(pendingItem.sn), apiName, req));\r\n                promise = new Promise(function (rs) { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n                    var service, opEncode, promiseReturn, promiseSend, opSend, ret;\r\n                    var _a;\r\n                    return tslib.__generator(this, function (_b) {\r\n                        switch (_b.label) {\r\n                            case 0:\r\n                                service = this.serviceMap.apiName2Service[apiName];\r\n                                if (!service) {\r\n                                    rs({\r\n                                        isSucc: false,\r\n                                        err: new tsrpcProto.TsrpcError('Invalid api name: ' + apiName, {\r\n                                            code: 'INVALID_API_NAME',\r\n                                            type: tsrpcProto.TsrpcErrorType.ClientError\r\n                                        })\r\n                                    });\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                pendingItem.service = service;\r\n                                opEncode = TransportDataUtil.encodeApiReq(this.tsbuffer, service, req, this.dataType, this.type === 'LONG' ? pendingItem.sn : undefined);\r\n                                if (!opEncode.isSucc) {\r\n                                    rs({\r\n                                        isSucc: false, err: new tsrpcProto.TsrpcError(opEncode.errMsg, {\r\n                                            type: tsrpcProto.TsrpcErrorType.ClientError,\r\n                                            code: 'INPUT_DATA_ERR'\r\n                                        })\r\n                                    });\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                promiseReturn = this._waitApiReturn(pendingItem, (_a = options.timeout) !== null && _a !== void 0 ? _a : this.options.timeout);\r\n                                promiseSend = this.sendData(opEncode.output, options, service.id, pendingItem);\r\n                                return [4 /*yield*/, promiseSend];\r\n                            case 1:\r\n                                opSend = _b.sent();\r\n                                if (opSend.err) {\r\n                                    rs({\r\n                                        isSucc: false,\r\n                                        err: opSend.err\r\n                                    });\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                return [4 /*yield*/, promiseReturn];\r\n                            case 2:\r\n                                ret = _b.sent();\r\n                                if (pendingItem.isAborted) {\r\n                                    return [2 /*return*/];\r\n                                }\r\n                                rs(ret);\r\n                                return [2 /*return*/];\r\n                        }\r\n                    });\r\n                }); });\r\n                return [2 /*return*/, promise];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Send message, without response, not ensuring the server is received and processed correctly.\r\n     * @param msgName\r\n     * @param msg - Message body\r\n     * @param options - Transport options\r\n     * @returns If the promise is resolved, it means the request is sent to system kernel successfully.\r\n     * Notice that not means the server received and processed the message correctly.\r\n     */\r\n    BaseClient.prototype.sendMsg = function (msgName, msg, options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        var promise = new Promise(function (rs) { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n            var pre, service, opEncode, promiseSend, opSend;\r\n            var _a, _b;\r\n            return tslib.__generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0: return [4 /*yield*/, this.flows.preSendMsgFlow.exec({\r\n                            msgName: msgName,\r\n                            msg: msg,\r\n                            options: options\r\n                        }, this.logger)];\r\n                    case 1:\r\n                        pre = _c.sent();\r\n                        if (!pre) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        // The msg is not prevented by pre flow\r\n                        this.options.logMsg && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(\"[SendMsg]\", msgName, msg));\r\n                        service = this.serviceMap.msgName2Service[msgName];\r\n                        if (!service) {\r\n                            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error('Invalid msg name: ' + msgName);\r\n                            rs({\r\n                                isSucc: false,\r\n                                err: new tsrpcProto.TsrpcError('Invalid msg name: ' + msgName, {\r\n                                    code: 'INVALID_MSG_NAME',\r\n                                    type: tsrpcProto.TsrpcErrorType.ClientError\r\n                                })\r\n                            });\r\n                            return [2 /*return*/];\r\n                        }\r\n                        opEncode = TransportDataUtil.encodeClientMsg(this.tsbuffer, service, msg, this.dataType, this.type);\r\n                        if (!opEncode.isSucc) {\r\n                            rs({\r\n                                isSucc: false,\r\n                                err: new tsrpcProto.TsrpcError(opEncode.errMsg, {\r\n                                    type: tsrpcProto.TsrpcErrorType.ClientError,\r\n                                    code: 'ENCODE_MSG_ERR'\r\n                                })\r\n                            });\r\n                            return [2 /*return*/];\r\n                        }\r\n                        promiseSend = this.sendData(opEncode.output, options, service.id);\r\n                        return [4 /*yield*/, promiseSend];\r\n                    case 2:\r\n                        opSend = _c.sent();\r\n                        if (opSend.err) {\r\n                            rs({\r\n                                isSucc: false,\r\n                                err: opSend.err\r\n                            });\r\n                            return [2 /*return*/];\r\n                        }\r\n                        rs({ isSucc: true });\r\n                        // Post Flow\r\n                        this.flows.postSendMsgFlow.exec(pre, this.logger);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n        promise.then(function (v) {\r\n            var _a;\r\n            if (!v.isSucc) {\r\n                ((_a = _this.logger) !== null && _a !== void 0 ? _a : console).error('[SendMsgErr]', v.err);\r\n            }\r\n        });\r\n        return promise;\r\n    };\r\n    /**\r\n     * Add a message handler,\r\n     * duplicate handlers to the same `msgName` would be ignored.\r\n     * @param msgName\r\n     * @param handler\r\n     * @returns\r\n     */\r\n    // listenMsg<T extends keyof ServiceType['msg']>(msgName: T, handler: ClientMsgHandler<ServiceType, T, this>): ClientMsgHandler<ServiceType, T, this>;\r\n    // listenMsg(msgName: RegExp, handler: ClientMsgHandler<ServiceType, keyof ServiceType['msg'], this>): ClientMsgHandler<ServiceType, keyof ServiceType['msg'], this>;\r\n    // listenMsg(msgName: string | RegExp, handler: ClientMsgHandler<ServiceType, string, this>): ClientMsgHandler<ServiceType, string, this> {\r\n    BaseClient.prototype.listenMsg = function (msgName, handler) {\r\n        var _this = this;\r\n        if (msgName instanceof RegExp) {\r\n            Object.keys(this.serviceMap.msgName2Service).filter(function (k) { return msgName.test(k); }).forEach(function (k) {\r\n                _this._msgHandlers.addHandler(k, handler);\r\n            });\r\n        }\r\n        else {\r\n            this._msgHandlers.addHandler(msgName, handler);\r\n        }\r\n        return handler;\r\n    };\r\n    /**\r\n     * Remove a message handler\r\n     */\r\n    BaseClient.prototype.unlistenMsg = function (msgName, handler) {\r\n        var _this = this;\r\n        if (msgName instanceof RegExp) {\r\n            Object.keys(this.serviceMap.msgName2Service).filter(function (k) { return msgName.test(k); }).forEach(function (k) {\r\n                _this._msgHandlers.removeHandler(k, handler);\r\n            });\r\n        }\r\n        else {\r\n            this._msgHandlers.removeHandler(msgName, handler);\r\n        }\r\n    };\r\n    /**\r\n     * Remove all handlers from a message\r\n     */\r\n    BaseClient.prototype.unlistenMsgAll = function (msgName) {\r\n        var _this = this;\r\n        if (msgName instanceof RegExp) {\r\n            Object.keys(this.serviceMap.msgName2Service).filter(function (k) { return msgName.test(k); }).forEach(function (k) {\r\n                _this._msgHandlers.removeAllHandlers(k);\r\n            });\r\n        }\r\n        else {\r\n            this._msgHandlers.removeAllHandlers(msgName);\r\n        }\r\n    };\r\n    /**\r\n     * Abort a pending API request, it makes the promise returned by `callApi()` neither resolved nor rejected forever.\r\n     * @param sn - Every api request has a unique `sn` number, you can get it by `this.lastSN`\r\n     */\r\n    BaseClient.prototype.abort = function (sn) {\r\n        var _a, _b;\r\n        // Find\r\n        var index = this._pendingApis.findIndex(function (v) { return v.sn === sn; });\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        var pendingItem = this._pendingApis[index];\r\n        // Clear\r\n        this._pendingApis.splice(index, 1);\r\n        pendingItem.onReturn = undefined;\r\n        pendingItem.isAborted = true;\r\n        // Log\r\n        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(\"[ApiAbort] #\".concat(pendingItem.sn, \" \").concat(pendingItem.service.name));\r\n        // onAbort\r\n        (_b = pendingItem.onAbort) === null || _b === void 0 ? void 0 : _b.call(pendingItem);\r\n    };\r\n    /**\r\n     * Abort all API requests that has the `abortKey`.\r\n     * It makes the promise returned by `callApi` neither resolved nor rejected forever.\r\n     * @param abortKey - The `abortKey` of options when `callApi()`, see {@link TransportOptions.abortKey}.\r\n     * @example\r\n     * ```ts\r\n     * // Send API request many times\r\n     * client.callApi('SendData', { data: 'AAA' }, { abortKey: 'Session#123' });\r\n     * client.callApi('SendData', { data: 'BBB' }, { abortKey: 'Session#123' });\r\n     * client.callApi('SendData', { data: 'CCC' }, { abortKey: 'Session#123' });\r\n     *\r\n     * // And abort the at once\r\n     * client.abortByKey('Session#123');\r\n     * ```\r\n     */\r\n    BaseClient.prototype.abortByKey = function (abortKey) {\r\n        var _this = this;\r\n        this._pendingApis.filter(function (v) { return v.abortKey === abortKey; }).forEach(function (v) { _this.abort(v.sn); });\r\n    };\r\n    /**\r\n     * Abort all pending API requests.\r\n     * It makes the promise returned by `callApi` neither resolved nor rejected forever.\r\n     */\r\n    BaseClient.prototype.abortAll = function () {\r\n        var _this = this;\r\n        this._pendingApis.slice().forEach(function (v) { return _this.abort(v.sn); });\r\n    };\r\n    /**\r\n     * Send data (binary or text)\r\n     * @remarks\r\n     * Long connection: wait res by listenning `conn.onmessage`\r\n     * Short connection: wait res by waitting response\r\n     * @param data\r\n     * @param options\r\n     * @param sn\r\n     */\r\n    BaseClient.prototype.sendData = function (data, options, serviceId, pendingApiItem) {\r\n        var _a, _b, _c;\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var pre, preBuf;\r\n            return tslib.__generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0: return [4 /*yield*/, this.flows.preSendDataFlow.exec({ data: data, sn: pendingApiItem === null || pendingApiItem === void 0 ? void 0 : pendingApiItem.sn }, this.logger)];\r\n                    case 1:\r\n                        pre = _d.sent();\r\n                        if (!pre) {\r\n                            return [2 /*return*/, new Promise(function (rs) { })];\r\n                        }\r\n                        data = pre.data;\r\n                        if (!(data instanceof Uint8Array)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.flows.preSendBufferFlow.exec({ buf: data, sn: pendingApiItem === null || pendingApiItem === void 0 ? void 0 : pendingApiItem.sn }, this.logger)];\r\n                    case 2:\r\n                        preBuf = _d.sent();\r\n                        if (!preBuf) {\r\n                            return [2 /*return*/, new Promise(function (rs) { })];\r\n                        }\r\n                        data = preBuf.buf;\r\n                        _d.label = 3;\r\n                    case 3:\r\n                        // debugBuf log\r\n                        if (this.options.debugBuf) {\r\n                            if (typeof data === 'string') {\r\n                                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('[SendText]' + (pendingApiItem ? (' #' + pendingApiItem.sn) : '') + \" length=\".concat(data.length), data);\r\n                            }\r\n                            else if (data instanceof Uint8Array) {\r\n                                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug('[SendBuf]' + (pendingApiItem ? (' #' + pendingApiItem.sn) : '') + \" length=\".concat(data.length), data);\r\n                            }\r\n                            else {\r\n                                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug('[SendJSON]' + (pendingApiItem ? (' #' + pendingApiItem.sn) : ''), data);\r\n                            }\r\n                        }\r\n                        return [2 /*return*/, this._sendData(data, options, serviceId, pendingApiItem)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    // 信道可传输二进制或字符串\r\n    BaseClient.prototype._onRecvData = function (data, pendingApiItem) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var sn, pre, pre_1, opParsed, parsed, pre_2;\r\n            return tslib.__generator(this, function (_k) {\r\n                switch (_k.label) {\r\n                    case 0:\r\n                        sn = pendingApiItem === null || pendingApiItem === void 0 ? void 0 : pendingApiItem.sn;\r\n                        return [4 /*yield*/, this.flows.preRecvDataFlow.exec({ data: data, sn: sn }, this.logger)];\r\n                    case 1:\r\n                        pre = _k.sent();\r\n                        if (!pre) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        data = pre.data;\r\n                        if (!(typeof data === 'string')) return [3 /*break*/, 2];\r\n                        this.options.debugBuf && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('[RecvText]' + (sn ? (' #' + sn) : ''), data));\r\n                        return [3 /*break*/, 5];\r\n                    case 2:\r\n                        if (!(data instanceof Uint8Array)) return [3 /*break*/, 4];\r\n                        this.options.debugBuf && ((_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug('[RecvBuf]' + (sn ? (' #' + sn) : ''), 'length=' + data.length, data));\r\n                        return [4 /*yield*/, this.flows.preRecvBufferFlow.exec({ buf: data, sn: sn }, this.logger)];\r\n                    case 3:\r\n                        pre_1 = _k.sent();\r\n                        if (!pre_1) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        data = pre_1.buf;\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        this.options.debugBuf && ((_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug('[RecvJSON]' + (sn ? (' #' + sn) : ''), data));\r\n                        _k.label = 5;\r\n                    case 5:\r\n                        opParsed = TransportDataUtil.parseServerOutout(this.tsbuffer, this.serviceMap, data, pendingApiItem === null || pendingApiItem === void 0 ? void 0 : pendingApiItem.service.id);\r\n                        if (!opParsed.isSucc) {\r\n                            (_d = this.logger) === null || _d === void 0 ? void 0 : _d.error('ParseServerOutputError: ' + opParsed.errMsg);\r\n                            if (data instanceof Uint8Array) {\r\n                                (_e = this.logger) === null || _e === void 0 ? void 0 : _e.error('Please check the version of serviceProto between server and client');\r\n                            }\r\n                            if (pendingApiItem) {\r\n                                (_f = pendingApiItem.onReturn) === null || _f === void 0 ? void 0 : _f.call(pendingApiItem, {\r\n                                    isSucc: false,\r\n                                    err: new tsrpcProto.TsrpcError('Parse server output error', { type: tsrpcProto.TsrpcErrorType.ServerError })\r\n                                });\r\n                            }\r\n                            return [2 /*return*/];\r\n                        }\r\n                        parsed = opParsed.result;\r\n                        if (!(parsed.type === 'api')) return [3 /*break*/, 6];\r\n                        sn = sn !== null && sn !== void 0 ? sn : parsed.sn;\r\n                        // call ApiReturn listeners\r\n                        (_h = (_g = this._pendingApis.find(function (v) { return v.sn === sn; })) === null || _g === void 0 ? void 0 : _g.onReturn) === null || _h === void 0 ? void 0 : _h.call(_g, parsed.ret);\r\n                        return [3 /*break*/, 9];\r\n                    case 6:\r\n                        if (!(parsed.type === 'msg')) return [3 /*break*/, 9];\r\n                        this.options.logMsg && ((_j = this.logger) === null || _j === void 0 ? void 0 : _j.log(\"[RecvMsg] \".concat(parsed.service.name), parsed.msg));\r\n                        return [4 /*yield*/, this.flows.preRecvMsgFlow.exec({ msgName: parsed.service.name, msg: parsed.msg }, this.logger)];\r\n                    case 7:\r\n                        pre_2 = _k.sent();\r\n                        if (!pre_2) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this._msgHandlers.forEachHandler(pre_2.msgName, this.logger, pre_2.msg, pre_2.msgName);\r\n                        // Post Flow\r\n                        return [4 /*yield*/, this.flows.postRecvMsgFlow.exec(pre_2, this.logger)];\r\n                    case 8:\r\n                        // Post Flow\r\n                        _k.sent();\r\n                        _k.label = 9;\r\n                    case 9: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * @param sn\r\n     * @param timeout\r\n     * @returns `undefined` 代表 canceled\r\n     */\r\n    BaseClient.prototype._waitApiReturn = function (pendingItem, timeout) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                return [2 /*return*/, new Promise(function (rs) {\r\n                        // Timeout\r\n                        var timer;\r\n                        if (timeout) {\r\n                            timer = setTimeout(function () {\r\n                                timer = undefined;\r\n                                _this._pendingApis.removeOne(function (v) { return v.sn === pendingItem.sn; });\r\n                                rs({\r\n                                    isSucc: false,\r\n                                    err: new tsrpcProto.TsrpcError('Request Timeout', {\r\n                                        type: tsrpcProto.TsrpcErrorType.NetworkError,\r\n                                        code: 'TIMEOUT'\r\n                                    })\r\n                                });\r\n                            }, timeout);\r\n                        }\r\n                        // Listener (trigger by `this._onRecvBuf`)\r\n                        pendingItem.onReturn = function (ret) {\r\n                            if (timer) {\r\n                                clearTimeout(timer);\r\n                                timer = undefined;\r\n                            }\r\n                            _this._pendingApis.removeOne(function (v) { return v.sn === pendingItem.sn; });\r\n                            rs(ret);\r\n                        };\r\n                    })];\r\n            });\r\n        });\r\n    };\r\n    return BaseClient;\r\n}());\r\nvar defaultBaseClientOptions = {\r\n    logLevel: 'debug',\r\n    logApi: true,\r\n    logMsg: true,\r\n    json: false,\r\n    timeout: 15000,\r\n    debugBuf: false\r\n};\n\n/**\r\n * Base HTTP Client\r\n */\r\nvar BaseHttpClient = /** @class */ (function (_super) {\r\n    tslib.__extends(BaseHttpClient, _super);\r\n    function BaseHttpClient(proto, http, options) {\r\n        var _this = this;\r\n        var _a;\r\n        _this = _super.call(this, proto, tslib.__assign(tslib.__assign({}, defaultBaseHttpClientOptions), options)) || this;\r\n        _this.type = 'SHORT';\r\n        _this._http = http;\r\n        _this._jsonServer = _this.options.server + (_this.options.server.endsWith('/') ? '' : '/');\r\n        (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.log('TSRPC HTTP Client :', _this.options.server);\r\n        return _this;\r\n    }\r\n    BaseHttpClient.prototype._sendData = function (data, options, serviceId, pendingApiItem) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var promise;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                promise = (function () { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n                    var service, urlSearch, url, _a, fetchPromise, abort, fetchRes;\r\n                    return tslib.__generator(this, function (_b) {\r\n                        switch (_b.label) {\r\n                            case 0:\r\n                                service = this.serviceMap.id2Service[serviceId];\r\n                                urlSearch = service.type === 'msg' ? '?type=msg' : '';\r\n                                url = typeof data === 'string' ? (this._jsonServer + service.name + urlSearch) : this.options.server;\r\n                                _a = this._http.fetch({\r\n                                    url: url,\r\n                                    data: data,\r\n                                    method: 'POST',\r\n                                    timeout: options.timeout || this.options.timeout,\r\n                                    headers: { 'Content-Type': typeof data === 'string' ? 'application/json' : 'application/octet-stream' },\r\n                                    transportOptions: options,\r\n                                    responseType: typeof data === 'string' ? 'text' : 'arraybuffer',\r\n                                }), fetchPromise = _a.promise, abort = _a.abort;\r\n                                if (pendingApiItem) {\r\n                                    pendingApiItem.onAbort = function () {\r\n                                        abort();\r\n                                    };\r\n                                }\r\n                                // Aborted\r\n                                if (pendingApiItem === null || pendingApiItem === void 0 ? void 0 : pendingApiItem.isAborted) {\r\n                                    return [2 /*return*/, new Promise(function (rs) { })];\r\n                                }\r\n                                return [4 /*yield*/, fetchPromise];\r\n                            case 1:\r\n                                fetchRes = _b.sent();\r\n                                if (!fetchRes.isSucc) {\r\n                                    return [2 /*return*/, { err: fetchRes.err }];\r\n                                }\r\n                                return [2 /*return*/, { res: fetchRes.res }];\r\n                        }\r\n                    });\r\n                }); })();\r\n                promise.then(function (v) {\r\n                    // Msg 不需要 onRecvData\r\n                    if (pendingApiItem && v.res) {\r\n                        _this._onRecvData(v.res, pendingApiItem);\r\n                    }\r\n                });\r\n                // Finally\r\n                promise.catch(function (e) { }).then(function () {\r\n                    if (pendingApiItem) {\r\n                        pendingApiItem.onAbort = undefined;\r\n                    }\r\n                });\r\n                return [2 /*return*/, promise];\r\n            });\r\n        });\r\n    };\r\n    return BaseHttpClient;\r\n}(BaseClient));\r\nvar defaultBaseHttpClientOptions = tslib.__assign(tslib.__assign({}, defaultBaseClientOptions), { server: 'http://localhost:3000', \r\n    // logger: new TerminalColorLogger(),\r\n    jsonPrune: true });\n\n/**\r\n * WebSocket Client for TSRPC.\r\n * It uses native `WebSocket` of browser.\r\n * @typeParam ServiceType - `ServiceType` from generated `proto.ts`\r\n */\r\nvar BaseWsClient = /** @class */ (function (_super) {\r\n    tslib.__extends(BaseWsClient, _super);\r\n    function BaseWsClient(proto, wsp, options) {\r\n        var _this = this;\r\n        var _a;\r\n        _this = _super.call(this, proto, tslib.__assign(tslib.__assign({}, defaultBaseWsClientOptions), options)) || this;\r\n        _this.type = 'LONG';\r\n        _this._onWsOpen = function () {\r\n            var _a;\r\n            if (!_this._connecting) {\r\n                return;\r\n            }\r\n            _this._status = exports.WsClientStatus.Opened;\r\n            _this._connecting.rs({ isSucc: true });\r\n            _this._connecting = undefined;\r\n            (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.log('WebSocket connection to server successful');\r\n            _this.flows.postConnectFlow.exec({}, _this.logger);\r\n            // First heartbeat\r\n            if (_this.options.heartbeat) {\r\n                _this._heartbeat();\r\n            }\r\n        };\r\n        _this._onWsClose = function (code, reason) {\r\n            var _a, _b, _c;\r\n            // 防止重复执行\r\n            if (_this._status === exports.WsClientStatus.Closed) {\r\n                return;\r\n            }\r\n            var isManual = !!_this._rsDisconnecting;\r\n            var isConnectedBefore = _this.isConnected || isManual;\r\n            _this._status = exports.WsClientStatus.Closed;\r\n            // 连接中，返回连接失败\r\n            if (_this._connecting) {\r\n                _this._connecting.rs({\r\n                    isSucc: false,\r\n                    errMsg: \"Failed to connect to WebSocket server: \".concat(_this.options.server)\r\n                });\r\n                _this._connecting = undefined;\r\n                (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.error(\"Failed to connect to WebSocket server: \".concat(_this.options.server));\r\n            }\r\n            // Clear heartbeat\r\n            if (_this._pendingHeartbeat) {\r\n                clearTimeout(_this._pendingHeartbeat.timeoutTimer);\r\n                _this._pendingHeartbeat = undefined;\r\n            }\r\n            if (_this._nextHeartbeatTimer) {\r\n                clearTimeout(_this._nextHeartbeatTimer);\r\n            }\r\n            // disconnect中，返回成功\r\n            if (_this._rsDisconnecting) {\r\n                _this._rsDisconnecting();\r\n                _this._rsDisconnecting = undefined;\r\n                (_b = _this.logger) === null || _b === void 0 ? void 0 : _b.log('Disconnected succ', \"code=\".concat(code, \" reason=\").concat(reason));\r\n            }\r\n            // 非 disconnect 中，从连接中意外断开\r\n            else if (isConnectedBefore) {\r\n                (_c = _this.logger) === null || _c === void 0 ? void 0 : _c.log(\"Lost connection to \".concat(_this.options.server), \"code=\".concat(code, \" reason=\").concat(reason));\r\n            }\r\n            // postDisconnectFlow，仅从连接状态断开时触发\r\n            if (isConnectedBefore) {\r\n                _this.flows.postDisconnectFlow.exec({\r\n                    reason: reason,\r\n                    isManual: isManual\r\n                }, _this.logger);\r\n            }\r\n            // 对所有请求中的 API 报错\r\n            _this._pendingApis.slice().forEach(function (v) {\r\n                var _a;\r\n                (_a = v.onReturn) === null || _a === void 0 ? void 0 : _a.call(v, {\r\n                    isSucc: false,\r\n                    err: new tsrpcProto.TsrpcError(reason || 'Lost connection to server', { type: tsrpcProto.TsrpcErrorType.NetworkError, code: 'LOST_CONN' })\r\n                });\r\n            });\r\n        };\r\n        _this._onWsError = function (e) {\r\n            var _a, _b;\r\n            (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.error('[WebSocket Error]', e);\r\n            // 连接中，返回连接失败\r\n            if (_this._connecting) {\r\n                _this._connecting.rs({\r\n                    isSucc: false,\r\n                    errMsg: \"Failed to connect to WebSocket server: \".concat(_this.options.server)\r\n                });\r\n                _this._connecting = undefined;\r\n                (_b = _this.logger) === null || _b === void 0 ? void 0 : _b.error(\"Failed to connect to WebSocket server: \".concat(_this.options.server));\r\n            }\r\n        };\r\n        _this._onWsMessage = function (data) {\r\n            if (_this._status !== exports.WsClientStatus.Opened) {\r\n                return;\r\n            }\r\n            // 心跳包回包\r\n            if (data instanceof Uint8Array && data.length === TransportDataUtil.HeartbeatPacket.length && data.every(function (v, i) { return v === TransportDataUtil.HeartbeatPacket[i]; })) {\r\n                _this._onHeartbeatAnswer(data);\r\n                return;\r\n            }\r\n            _this._onRecvData(data);\r\n        };\r\n        // #region Heartbeat\r\n        /**\r\n         * Last latency time (ms) of heartbeat test\r\n         */\r\n        _this.lastHeartbeatLatency = 0;\r\n        // #endregion\r\n        _this._status = exports.WsClientStatus.Closed;\r\n        _this._wsp = wsp;\r\n        wsp.options = {\r\n            onOpen: _this._onWsOpen,\r\n            onClose: _this._onWsClose,\r\n            onError: _this._onWsError,\r\n            onMessage: _this._onWsMessage,\r\n            logger: _this.logger\r\n        };\r\n        (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.log('TSRPC WebSocket Client :', _this.options.server);\r\n        return _this;\r\n    }\r\n    BaseWsClient.prototype._sendData = function (data) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                return [2 /*return*/, new Promise(function (rs) { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n                        return tslib.__generator(this, function (_a) {\r\n                            if (!this.isConnected) {\r\n                                rs({\r\n                                    err: new tsrpcProto.TsrpcError('WebSocket is not connected', {\r\n                                        code: 'WS_NOT_OPEN',\r\n                                        type: tsrpcProto.TsrpcError.Type.ClientError\r\n                                    })\r\n                                });\r\n                                return [2 /*return*/];\r\n                            }\r\n                            // Do Send\r\n                            rs(this._wsp.send(data));\r\n                            return [2 /*return*/];\r\n                        });\r\n                    }); })];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Send a heartbeat packet\r\n     */\r\n    BaseWsClient.prototype._heartbeat = function () {\r\n        var _this = this;\r\n        var _a;\r\n        if (this._pendingHeartbeat || this._status !== exports.WsClientStatus.Opened || !this.options.heartbeat) {\r\n            return;\r\n        }\r\n        this._pendingHeartbeat = {\r\n            startTime: Date.now(),\r\n            timeoutTimer: setTimeout(function () {\r\n                var _a;\r\n                _this._pendingHeartbeat = undefined;\r\n                // heartbeat timeout, disconnect if still connected\r\n                (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.error('[Heartbeat] Heartbeat timeout, the connection disconnected automatically.');\r\n                if (_this._status === exports.WsClientStatus.Opened) {\r\n                    _this._wsClose(3000, 'Heartbeat timeout');\r\n                    _this._wsp.options.onClose(3000, 'Heartbeat timeout');\r\n                }\r\n            }, this.options.heartbeat.timeout)\r\n        };\r\n        this.options.debugBuf && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.log('[Heartbeat] Send ping', TransportDataUtil.HeartbeatPacket));\r\n        this._sendData(TransportDataUtil.HeartbeatPacket);\r\n    };\r\n    BaseWsClient.prototype._onHeartbeatAnswer = function (data) {\r\n        var _this = this;\r\n        var _a;\r\n        if (!this._pendingHeartbeat || this._status !== exports.WsClientStatus.Opened || !this.options.heartbeat) {\r\n            return;\r\n        }\r\n        // heartbeat succ\r\n        this.lastHeartbeatLatency = Date.now() - this._pendingHeartbeat.startTime;\r\n        this.options.debugBuf && ((_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(\"[Heartbeat] Recv pong, latency=\".concat(this.lastHeartbeatLatency, \"ms\"), data));\r\n        clearTimeout(this._pendingHeartbeat.timeoutTimer);\r\n        this._pendingHeartbeat = undefined;\r\n        // next heartbeat timer\r\n        this._nextHeartbeatTimer = setTimeout(function () {\r\n            _this._heartbeat();\r\n        }, this.options.heartbeat.interval);\r\n    };\r\n    Object.defineProperty(BaseWsClient.prototype, \"status\", {\r\n        get: function () {\r\n            return this._status;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseWsClient.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this._status === exports.WsClientStatus.Opened;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Start connecting, you must connect first before `callApi()` and `sendMsg()`.\r\n     * @throws never\r\n     */\r\n    BaseWsClient.prototype.connect = function () {\r\n        var _a, _b;\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var pre, promiseConnect;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        // 已连接成功\r\n                        if (this.isConnected) {\r\n                            return [2 /*return*/, { isSucc: true }];\r\n                        }\r\n                        // 已连接中\r\n                        if (this._connecting) {\r\n                            return [2 /*return*/, this._connecting.promise];\r\n                        }\r\n                        return [4 /*yield*/, this.flows.preConnectFlow.exec({}, this.logger)];\r\n                    case 1:\r\n                        pre = _c.sent();\r\n                        // Pre return\r\n                        if (pre === null || pre === void 0 ? void 0 : pre.return) {\r\n                            return [2 /*return*/, pre.return];\r\n                        }\r\n                        // Canceled\r\n                        if (!pre) {\r\n                            return [2 /*return*/, new Promise(function (rs) { })];\r\n                        }\r\n                        try {\r\n                            this._wsp.connect(this.options.server, [this.options.json ? 'text' : 'buffer']);\r\n                        }\r\n                        catch (e) {\r\n                            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(e);\r\n                            return [2 /*return*/, { isSucc: false, errMsg: e.message }];\r\n                        }\r\n                        this._status = exports.WsClientStatus.Opening;\r\n                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.log(\"Start connecting \".concat(this.options.server, \"...\"));\r\n                        this._connecting = {};\r\n                        promiseConnect = new Promise(function (rs) {\r\n                            _this._connecting.rs = rs;\r\n                        });\r\n                        this._connecting.promise = promiseConnect;\r\n                        return [2 /*return*/, promiseConnect];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Disconnect immediately\r\n     * @throws never\r\n     */\r\n    BaseWsClient.prototype.disconnect = function (code, reason) {\r\n        var _a;\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var isClosed;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_b) {\r\n                if (this._status === exports.WsClientStatus.Closed) {\r\n                    return [2 /*return*/];\r\n                }\r\n                this._status = exports.WsClientStatus.Closing;\r\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log('Start disconnecting...');\r\n                isClosed = false;\r\n                return [2 /*return*/, Promise.race([\r\n                        // 正常等待 onClose 关闭\r\n                        new Promise(function (rs) {\r\n                            _this._rsDisconnecting = function () {\r\n                                if (isClosed) {\r\n                                    return;\r\n                                }\r\n                                isClosed = true;\r\n                                rs();\r\n                            };\r\n                            _this._wsClose(code !== null && code !== void 0 ? code : 1000, reason !== null && reason !== void 0 ? reason : '');\r\n                        }),\r\n                        // 超时保护，1 秒未收到关闭请求的，直接 onClose 掉\r\n                        new Promise(function (rs) {\r\n                            setTimeout(function () {\r\n                                if (isClosed) {\r\n                                    return;\r\n                                }\r\n                                isClosed = true;\r\n                                _this._onWsClose(1005, 'Connection closed, but not received ws.onClose event.');\r\n                            }, 1000);\r\n                        })\r\n                    ])];\r\n            });\r\n        });\r\n    };\r\n    BaseWsClient.prototype._wsClose = function (code, reason) {\r\n        var _a;\r\n        try {\r\n            this._wsp.close(code !== null && code !== void 0 ? code : 1000, reason !== null && reason !== void 0 ? reason : '');\r\n        }\r\n        catch (e) {\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('[WsCloseError]', e);\r\n        }\r\n    };\r\n    return BaseWsClient;\r\n}(BaseClient));\r\nvar defaultBaseWsClientOptions = tslib.__assign(tslib.__assign({}, defaultBaseClientOptions), { server: 'ws://localhost:3000' });\r\nexports.WsClientStatus = void 0;\r\n(function (WsClientStatus) {\r\n    WsClientStatus[\"Opening\"] = \"OPENING\";\r\n    WsClientStatus[\"Opened\"] = \"OPENED\";\r\n    WsClientStatus[\"Closing\"] = \"CLOSING\";\r\n    WsClientStatus[\"Closed\"] = \"CLOSED\";\r\n})(exports.WsClientStatus || (exports.WsClientStatus = {}));\n\nexports.BaseClient = BaseClient;\nexports.BaseHttpClient = BaseHttpClient;\nexports.BaseWsClient = BaseWsClient;\nexports.Counter = Counter;\nexports.Flow = Flow;\nexports.MsgHandlerManager = MsgHandlerManager;\nexports.ServiceMapUtil = ServiceMapUtil;\nexports.TransportDataUtil = TransportDataUtil;\nexports.defaultBaseClientOptions = defaultBaseClientOptions;\nexports.defaultBaseHttpClientOptions = defaultBaseHttpClientOptions;\nexports.defaultBaseWsClientOptions = defaultBaseWsClientOptions;\nexports.getCustomObjectIdTypes = getCustomObjectIdTypes;\n"]}