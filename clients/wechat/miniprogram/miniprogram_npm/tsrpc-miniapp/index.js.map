{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * TSRPC Miniapp v3.4.8\n * -----------------------------------------\n * Copyright (c) King Wang.\n * MIT License\n * https://github.com/k8w/tsrpc-miniapp\n */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('k8w-extend-native');\nvar tslib = require('tslib');\nvar tsrpcBaseClient = require('tsrpc-base-client');\nvar tsrpcProto = require('tsrpc-proto');\n\nvar HttpProxy = /** @class */ (function () {\r\n    function HttpProxy() {\r\n    }\r\n    HttpProxy.prototype.fetch = function (options) {\r\n        var _a;\r\n        if (!this.miniappObj) {\r\n            return {\r\n                abort: function () { },\r\n                promise: Promise.resolve({\r\n                    isSucc: false,\r\n                    err: new tsrpcProto.TsrpcError('miniappObj is not set, please check if this is miniapp environment.', { type: tsrpcProto.TsrpcError.Type.ClientError })\r\n                })\r\n            };\r\n        }\r\n        var rs;\r\n        var promise = new Promise(function (_rs) {\r\n            rs = _rs;\r\n        });\r\n        var data;\r\n        if (typeof options.data === 'string') {\r\n            data = options.data;\r\n        }\r\n        else {\r\n            var buf = options.data;\r\n            if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\r\n                data = buf.buffer;\r\n            }\r\n            else {\r\n                data = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n            }\r\n        }\r\n        var reqTask = this.miniappObj.request({\r\n            url: options.url,\r\n            data: data,\r\n            method: options.method,\r\n            header: (_a = options.headers) !== null && _a !== void 0 ? _a : {\r\n                'content-type': 'application/octet-stream'\r\n            },\r\n            dataType: '其他',\r\n            responseType: options.responseType,\r\n            success: function (res) {\r\n                if (res.statusCode === 200 || res.statusCode === 500) {\r\n                    rs({\r\n                        isSucc: true,\r\n                        res: typeof res.data === 'string' ? res.data : new Uint8Array(res.data)\r\n                    });\r\n                }\r\n                else {\r\n                    rs({\r\n                        isSucc: false,\r\n                        err: new tsrpcProto.TsrpcError({\r\n                            message: 'HTTP Error ' + res.statusCode,\r\n                            type: tsrpcProto.TsrpcError.Type.ServerError,\r\n                            httpCode: res.statusCode\r\n                        })\r\n                    });\r\n                }\r\n            },\r\n            fail: function (res) {\r\n                rs({\r\n                    isSucc: false,\r\n                    err: new tsrpcProto.TsrpcError({\r\n                        message: 'Network Error',\r\n                        type: tsrpcProto.TsrpcError.Type.NetworkError,\r\n                        innerErr: res\r\n                    })\r\n                });\r\n            }\r\n        });\r\n        var abort = reqTask.abort.bind(reqTask);\r\n        return {\r\n            promise: promise,\r\n            abort: abort\r\n        };\r\n    };\r\n    return HttpProxy;\r\n}());\n\n/**\r\n * Client for TSRPC HTTP Server.\r\n * It uses native http module of NodeJS.\r\n * @typeParam ServiceType - `ServiceType` from generated `proto.ts`\r\n */\r\nvar HttpClient = /** @class */ (function (_super) {\r\n    tslib.__extends(HttpClient, _super);\r\n    function HttpClient(proto, options) {\r\n        var _this = this;\r\n        var httpProxy = new HttpProxy;\r\n        _this = _super.call(this, proto, httpProxy, tslib.__assign(tslib.__assign({}, defaultHttpClientOptions), options)) || this;\r\n        httpProxy.miniappObj = _this.options.miniappObj;\r\n        return _this;\r\n    }\r\n    return HttpClient;\r\n}(tsrpcBaseClient.BaseHttpClient));\r\nvar defaultHttpClientOptions = tslib.__assign(tslib.__assign({}, tsrpcBaseClient.defaultBaseHttpClientOptions), { miniappObj: typeof wx !== 'undefined' ? wx : undefined, customObjectIdClass: String });\n\nvar WebSocketProxy = /** @class */ (function () {\r\n    function WebSocketProxy() {\r\n    }\r\n    WebSocketProxy.prototype.connect = function (server, protocols) {\r\n        var _this = this;\r\n        this._ws = this.miniappObj.connectSocket(tslib.__assign(tslib.__assign({}, this.client.options.connectSocketOptions), { url: server, protocols: protocols }));\r\n        this._ws.onOpen(function (header) {\r\n            _this.options.onOpen();\r\n        });\r\n        this._ws.onError(function (res) {\r\n            _this.options.onError(res);\r\n        });\r\n        this._ws.onClose(function (e) {\r\n            _this.options.onClose(e.code, e.reason);\r\n            _this._ws = undefined;\r\n        });\r\n        this._ws.onMessage(function (e) {\r\n            if (typeof e.data === 'string') {\r\n                _this.options.onMessage(e.data);\r\n            }\r\n            else {\r\n                _this.options.onMessage(new Uint8Array(e.data));\r\n            }\r\n        });\r\n    };\r\n    WebSocketProxy.prototype.close = function (code, reason) {\r\n        var _this = this;\r\n        var _a;\r\n        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close({\r\n            code: code,\r\n            reason: reason,\r\n            fail: function (res) {\r\n                var _a;\r\n                // 重试一次\r\n                console.error('WebSocket closed failed', res);\r\n                (_a = _this._ws) === null || _a === void 0 ? void 0 : _a.close();\r\n            }\r\n        });\r\n        this._ws = undefined;\r\n    };\r\n    WebSocketProxy.prototype.send = function (data) {\r\n        var _this = this;\r\n        var sendData;\r\n        if (typeof data === 'string') {\r\n            sendData = data;\r\n        }\r\n        else {\r\n            var buf = data;\r\n            if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\r\n                sendData = buf.buffer;\r\n            }\r\n            else {\r\n                sendData = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n            }\r\n        }\r\n        return new Promise(function (rs) {\r\n            _this._ws.send({\r\n                data: sendData,\r\n                success: function () { rs({}); },\r\n                fail: function (res) {\r\n                    rs({\r\n                        err: new tsrpcProto.TsrpcError({\r\n                            message: 'Network Error',\r\n                            type: tsrpcProto.TsrpcError.Type.NetworkError,\r\n                            innerErr: res\r\n                        })\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return WebSocketProxy;\r\n}());\n\n/**\r\n * Client for TSRPC WebSocket Server.\r\n * @typeParam ServiceType - `ServiceType` from generated `proto.ts`\r\n */\r\nvar WsClient = /** @class */ (function (_super) {\r\n    tslib.__extends(WsClient, _super);\r\n    function WsClient(proto, options) {\r\n        var _this = this;\r\n        var wsp = new WebSocketProxy();\r\n        _this = _super.call(this, proto, wsp, tslib.__assign(tslib.__assign({}, defaultWsClientOptions), options)) || this;\r\n        if (!_this.options.miniappObj) {\r\n            throw new Error('options.miniappObj is not set');\r\n        }\r\n        wsp.miniappObj = _this.options.miniappObj;\r\n        wsp.client = _this;\r\n        return _this;\r\n    }\r\n    return WsClient;\r\n}(tsrpcBaseClient.BaseWsClient));\r\nvar defaultWsClientOptions = tslib.__assign(tslib.__assign({}, tsrpcBaseClient.defaultBaseWsClientOptions), { miniappObj: typeof wx !== 'undefined' ? wx : undefined, customObjectIdClass: String });\r\nvar a;\r\nvar b = a;\r\nconsole.log(b);\n\nexports.HttpClient = HttpClient;\nexports.WsClient = WsClient;\nObject.keys(tsrpcProto).forEach(function (k) {\n    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function () { return tsrpcProto[k]; }\n    });\n});\n"]}