{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n * TSBuffer v2.2.6\n * -----------------------------------------\n * MIT LICENSE\n * KingWorks (C) Copyright 2022\n * https://github.com/k8w/tsbuffer\n */\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nrequire('k8w-extend-native');\nvar tslib = require('tslib');\nvar tsbufferValidator = require('tsbuffer-validator');\nvar tsbufferSchema = require('tsbuffer-schema');\n\nvar Base64Util = /** @class */ (function () {\r\n    function Base64Util() {\r\n    }\r\n    Base64Util.bufferToBase64 = function (buf) {\r\n        if (typeof Buffer !== 'undefined') {\r\n            return Buffer.from(buf).toString('base64');\r\n        }\r\n        var base64 = '';\r\n        var len = buf.length;\r\n        for (var i = 0; i < len; i += 3) {\r\n            base64 += base64Chars[buf[i] >> 2];\r\n            base64 += base64Chars[((buf[i] & 3) << 4) | (buf[i + 1] >> 4)];\r\n            base64 += base64Chars[((buf[i + 1] & 15) << 2) | (buf[i + 2] >> 6)];\r\n            base64 += base64Chars[buf[i + 2] & 63];\r\n        }\r\n        if (len % 3 === 2) {\r\n            base64 = base64.substring(0, base64.length - 1) + '=';\r\n        }\r\n        else if (len % 3 === 1) {\r\n            base64 = base64.substring(0, base64.length - 2) + '==';\r\n        }\r\n        return base64;\r\n    };\r\n    Base64Util.base64ToBuffer = function (base64) {\r\n        if (typeof Buffer !== 'undefined') {\r\n            return new Uint8Array(Buffer.from(base64, 'base64'));\r\n        }\r\n        var bufferLength = base64.length * 0.75, len = base64.length, p = 0;\r\n        var encoded1, encoded2, encoded3, encoded4;\r\n        if (base64[base64.length - 1] === '=') {\r\n            bufferLength--;\r\n            if (base64[base64.length - 2] === '=') {\r\n                bufferLength--;\r\n            }\r\n        }\r\n        var buf = new Uint8Array(bufferLength);\r\n        for (var i = 0; i < len; i += 4) {\r\n            encoded1 = lookup[base64.charCodeAt(i)];\r\n            encoded2 = lookup[base64.charCodeAt(i + 1)];\r\n            encoded3 = lookup[base64.charCodeAt(i + 2)];\r\n            encoded4 = lookup[base64.charCodeAt(i + 3)];\r\n            buf[p++] = (encoded1 << 2) | (encoded2 >> 4);\r\n            buf[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\r\n            buf[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\r\n        }\r\n        return buf;\r\n    };\r\n    return Base64Util;\r\n}());\r\n/*base64*/\r\nvar base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n// Use a lookup table to find the index.\r\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\r\nfor (var i = 0; i < base64Chars.length; i++) {\r\n    lookup[base64Chars.charCodeAt(i)] = i;\r\n}\r\n/*end*/\n\nvar CoderUtil = /** @class */ (function () {\r\n    function CoderUtil() {\r\n    }\r\n    CoderUtil.isJsonCompatible = function (schema, type, protoHelper) {\r\n        var _this = this;\r\n        var schemaInfo = schema;\r\n        var key = type === 'encode' ? 'isJsonEncodable' : 'isJsonDecodable';\r\n        if (schemaInfo[key] === undefined) {\r\n            switch (schema.type) {\r\n                case tsbufferSchema.SchemaType.Array:\r\n                    schemaInfo[key] = this.isJsonCompatible(schema.elementType, type, protoHelper);\r\n                    break;\r\n                case tsbufferSchema.SchemaType.Tuple:\r\n                    schemaInfo[key] = schema.elementTypes.every(function (v) { return _this.isJsonCompatible(v, type, protoHelper); });\r\n                    break;\r\n                case tsbufferSchema.SchemaType.Interface:\r\n                    var flatSchema = protoHelper.getFlatInterfaceSchema(schema);\r\n                    schemaInfo[key] = flatSchema.properties.every(function (v) { return _this.isJsonCompatible(v.type, type, protoHelper); });\r\n                    if (flatSchema.indexSignature) {\r\n                        schemaInfo[key] = schemaInfo[key] && this.isJsonCompatible(flatSchema.indexSignature.type, type, protoHelper);\r\n                    }\r\n                    break;\r\n                case tsbufferSchema.SchemaType.IndexedAccess:\r\n                case tsbufferSchema.SchemaType.Reference: {\r\n                    var parsed = protoHelper.parseReference(schema);\r\n                    schemaInfo[key] = this.isJsonCompatible(parsed, type, protoHelper);\r\n                    break;\r\n                }\r\n                case tsbufferSchema.SchemaType.Union:\r\n                case tsbufferSchema.SchemaType.Intersection:\r\n                    schemaInfo[key] = schema.members.every(function (v) { return _this.isJsonCompatible(v.type, type, protoHelper); });\r\n                    break;\r\n                case tsbufferSchema.SchemaType.NonNullable:\r\n                    schemaInfo[key] = this.isJsonCompatible(schema.target, type, protoHelper);\r\n                    break;\r\n                case tsbufferSchema.SchemaType.Pick:\r\n                case tsbufferSchema.SchemaType.Partial:\r\n                case tsbufferSchema.SchemaType.Omit:\r\n                case tsbufferSchema.SchemaType.Overwrite: {\r\n                    var parsed = protoHelper.parseMappedType(schema);\r\n                    schemaInfo[key] = this.isJsonCompatible(parsed, type, protoHelper);\r\n                    break;\r\n                }\r\n                case tsbufferSchema.SchemaType.Custom:\r\n                case tsbufferSchema.SchemaType.Date:\r\n                case tsbufferSchema.SchemaType.Buffer:\r\n                    schemaInfo[key] = false;\r\n                    break;\r\n                default:\r\n                    schemaInfo[key] = true;\r\n                    break;\r\n            }\r\n        }\r\n        return schemaInfo[key];\r\n    };\r\n    return CoderUtil;\r\n}());\n\n/** @internal */\r\nvar IdBlockUtil = /** @class */ (function () {\r\n    function IdBlockUtil() {\r\n    }\r\n    IdBlockUtil.getPayloadLengthInfo = function (parsedSchema, protoHelper) {\r\n        switch (parsedSchema.type) {\r\n            case tsbufferSchema.SchemaType.Boolean:\r\n            case tsbufferSchema.SchemaType.Enum:\r\n                return { lengthType: LengthType.Varint };\r\n            case tsbufferSchema.SchemaType.Number:\r\n                if (!parsedSchema.scalarType || parsedSchema.scalarType.includes('64') || parsedSchema.scalarType === 'double') {\r\n                    return { lengthType: LengthType.Bit64 };\r\n                }\r\n                else if (parsedSchema.scalarType && parsedSchema.scalarType.startsWith('big')) {\r\n                    return { lengthType: LengthType.LengthDelimited };\r\n                }\r\n                else {\r\n                    return { lengthType: LengthType.Varint };\r\n                }\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n            case tsbufferSchema.SchemaType.String:\r\n            case tsbufferSchema.SchemaType.Any:\r\n            case tsbufferSchema.SchemaType.Object:\r\n                return { lengthType: LengthType.LengthDelimited };\r\n            case tsbufferSchema.SchemaType.Interface:\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Union:\r\n            case tsbufferSchema.SchemaType.Intersection:\r\n                return { lengthType: LengthType.IdBlock };\r\n            case tsbufferSchema.SchemaType.Array:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n            case tsbufferSchema.SchemaType.Tuple:\r\n                return {\r\n                    lengthType: LengthType.LengthDelimited,\r\n                    needLengthPrefix: true\r\n                };\r\n            case tsbufferSchema.SchemaType.Literal:\r\n                return {\r\n                    lengthType: LengthType.LengthDelimited,\r\n                    needLengthPrefix: false\r\n                };\r\n            case tsbufferSchema.SchemaType.Date:\r\n                return { lengthType: LengthType.Varint };\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                return this.getPayloadLengthInfo(protoHelper.parseReference(parsedSchema.target), protoHelper);\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                return { lengthType: LengthType.LengthDelimited };\r\n            default:\r\n                // @ts-expect-error\r\n                throw new Error(\"Unrecognized schema type: \".concat(parsedSchema.type));\r\n        }\r\n    };\r\n    return IdBlockUtil;\r\n}());\r\n/** @internal */\r\nvar LengthType;\r\n(function (LengthType) {\r\n    LengthType[LengthType[\"LengthDelimited\"] = 0] = \"LengthDelimited\";\r\n    LengthType[LengthType[\"Varint\"] = 1] = \"Varint\";\r\n    LengthType[LengthType[\"Bit64\"] = 2] = \"Bit64\";\r\n    LengthType[LengthType[\"IdBlock\"] = 3] = \"IdBlock\";\r\n})(LengthType || (LengthType = {}));\n\n/** @internal */\r\nvar SchemaUtil = /** @class */ (function () {\r\n    function SchemaUtil() {\r\n    }\r\n    /** type类型是否能编码为该literal */\r\n    SchemaUtil.canBeLiteral = function (schema, literal) {\r\n        var _this = this;\r\n        if (schema.type === tsbufferSchema.SchemaType.Union) {\r\n            return schema.members.some(function (v) { return _this.canBeLiteral(v.type, literal); });\r\n        }\r\n        if (schema.type === tsbufferSchema.SchemaType.Any) {\r\n            return true;\r\n        }\r\n        if (schema.type === tsbufferSchema.SchemaType.Literal && schema.literal === literal) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return SchemaUtil;\r\n}());\n\nvar TypedArrays = {\r\n    Int8Array: Int8Array,\r\n    Int16Array: Int16Array,\r\n    Int32Array: Int32Array,\r\n    Uint8Array: Uint8Array,\r\n    Uint16Array: Uint16Array,\r\n    Uint32Array: Uint32Array,\r\n    Float32Array: Float32Array,\r\n    Float64Array: Float64Array\r\n};\n\n/**!\r\n * From [protobuf.js](https://github.com/protobufjs/protobuf.js/blob/master/lib/utf8/index.js)\r\n */\r\nvar Utf8CoderJS = {\r\n    measureLength: function (str) {\r\n        var len = 0, c = 0;\r\n        for (var i = 0; i < str.length; ++i) {\r\n            c = str.charCodeAt(i);\r\n            if (c < 128)\r\n                len += 1;\r\n            else if (c < 2048)\r\n                len += 2;\r\n            else if ((c & 0xFC00) === 0xD800 && (str.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n                ++i;\r\n                len += 4;\r\n            }\r\n            else\r\n                len += 3;\r\n        }\r\n        return len;\r\n    },\r\n    write: function (str, buf, pos) {\r\n        var start = pos, c1, // character 1\r\n        c2; // character 2\r\n        for (var i = 0; i < str.length; ++i) {\r\n            c1 = str.charCodeAt(i);\r\n            if (c1 < 128) {\r\n                buf[pos++] = c1;\r\n            }\r\n            else if (c1 < 2048) {\r\n                buf[pos++] = c1 >> 6 | 192;\r\n                buf[pos++] = c1 & 63 | 128;\r\n            }\r\n            else if ((c1 & 0xFC00) === 0xD800 && ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n                ++i;\r\n                buf[pos++] = c1 >> 18 | 240;\r\n                buf[pos++] = c1 >> 12 & 63 | 128;\r\n                buf[pos++] = c1 >> 6 & 63 | 128;\r\n                buf[pos++] = c1 & 63 | 128;\r\n            }\r\n            else {\r\n                buf[pos++] = c1 >> 12 | 224;\r\n                buf[pos++] = c1 >> 6 & 63 | 128;\r\n                buf[pos++] = c1 & 63 | 128;\r\n            }\r\n        }\r\n        return pos - start;\r\n    },\r\n    read: function (buf, pos, length) {\r\n        if (length < 1) {\r\n            return \"\";\r\n        }\r\n        var str = \"\";\r\n        for (var i = pos, end = pos + length; i < end;) {\r\n            var t = buf[i++];\r\n            if (t <= 0x7F) {\r\n                str += String.fromCharCode(t);\r\n            }\r\n            else if (t >= 0xC0 && t < 0xE0) {\r\n                str += String.fromCharCode((t & 0x1F) << 6 | buf[i++] & 0x3F);\r\n            }\r\n            else if (t >= 0xE0 && t < 0xF0) {\r\n                str += String.fromCharCode((t & 0xF) << 12 | (buf[i++] & 0x3F) << 6 | buf[i++] & 0x3F);\r\n            }\r\n            else if (t >= 0xF0) {\r\n                var t2 = ((t & 7) << 18 | (buf[i++] & 0x3F) << 12 | (buf[i++] & 0x3F) << 6 | buf[i++] & 0x3F) - 0x10000;\r\n                str += String.fromCharCode(0xD800 + (t2 >> 10));\r\n                str += String.fromCharCode(0xDC00 + (t2 & 0x3FF));\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n};\r\nvar Utf8CoderNode = {\r\n    measureLength: function (str) { return Buffer.byteLength(str, 'utf-8'); },\r\n    write: function (str, buf, pos) { return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).write(str, pos, 'utf-8'); },\r\n    read: function (buf, pos, length) { return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString('utf-8', pos, pos + length); }\r\n};\r\n/**\r\n * 自动判断环境，选择使用NodeJS Native方法编码或是JS编码\r\n */\r\nvar Utf8Coder = typeof Buffer !== 'undefined' && Buffer.from && Buffer.prototype.write ? Utf8CoderNode : Utf8CoderJS;\n\n/** @internal */\r\nvar Varint64 = /** @class */ (function () {\r\n    function Varint64(high, low, byteLength) {\r\n        this.uint32s = new Uint32Array([high, low]);\r\n        if (byteLength !== undefined) {\r\n            this._byteLength = byteLength;\r\n        }\r\n    }\r\n    Varint64.from = function (value) {\r\n        if (value === 0) {\r\n            return this.Zero;\r\n        }\r\n        var sign = value < 0;\r\n        if (sign) {\r\n            value = -value;\r\n        }\r\n        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\r\n        if (sign) {\r\n            hi = ~hi >>> 0;\r\n            lo = ~lo >>> 0;\r\n            if (++lo > 4294967295) {\r\n                lo = 0;\r\n                if (++hi > 4294967295)\r\n                    hi = 0;\r\n            }\r\n        }\r\n        return new Varint64(hi, lo);\r\n    };\r\n    Varint64.prototype.toNumber = function (unsigned) {\r\n        if (!unsigned && this.uint32s[0] >>> 31) {\r\n            var low = ~this.uint32s[1] + 1 >>> 0, high = ~this.uint32s[0] >>> 0;\r\n            if (!low)\r\n                high = high + 1 >>> 0;\r\n            return -(low + high * 4294967296);\r\n        }\r\n        return this.uint32s[1] + this.uint32s[0] * 4294967296;\r\n    };\r\n    Varint64.prototype.zzEncode = function () {\r\n        var mask = this.uint32s[0] >> 31;\r\n        this.uint32s[0] = ((this.uint32s[0] << 1 | this.uint32s[1] >>> 31) ^ mask) >>> 0;\r\n        this.uint32s[1] = (this.uint32s[1] << 1 ^ mask) >>> 0;\r\n        return this;\r\n    };\r\n    Varint64.prototype.zzDecode = function () {\r\n        var mask = -(this.uint32s[1] & 1);\r\n        this.uint32s[1] = ((this.uint32s[1] >>> 1 | this.uint32s[0] << 31) ^ mask) >>> 0;\r\n        this.uint32s[0] = (this.uint32s[0] >>> 1 ^ mask) >>> 0;\r\n        return this;\r\n    };\r\n    Object.defineProperty(Varint64.prototype, \"byteLength\", {\r\n        get: function () {\r\n            if (this._byteLength === undefined) {\r\n                var part0 = this.uint32s[1], part1 = (this.uint32s[1] >>> 28 | this.uint32s[0] << 4) >>> 0, part2 = this.uint32s[0] >>> 24;\r\n                this._byteLength = part2 === 0\r\n                    ? part1 === 0\r\n                        ? part0 < 16384\r\n                            ? part0 < 128 ? 1 : 2\r\n                            : part0 < 2097152 ? 3 : 4\r\n                        : part1 < 16384\r\n                            ? part1 < 128 ? 5 : 6\r\n                            : part1 < 2097152 ? 7 : 8\r\n                    : part2 < 128 ? 9 : 10;\r\n            }\r\n            return this._byteLength;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 编码\r\n     * @param buf\r\n     * @param pos\r\n     * @returns 编码后最新的pos\r\n     */\r\n    Varint64.prototype.writeToBuffer = function (buf, pos) {\r\n        while (this.uint32s[0]) {\r\n            buf[pos++] = this.uint32s[1] & 127 | 128;\r\n            this.uint32s[1] = (this.uint32s[1] >>> 7 | this.uint32s[0] << 25) >>> 0;\r\n            this.uint32s[0] >>>= 7;\r\n        }\r\n        while (this.uint32s[1] > 127) {\r\n            buf[pos++] = this.uint32s[1] & 127 | 128;\r\n            this.uint32s[1] = this.uint32s[1] >>> 7;\r\n        }\r\n        buf[pos++] = this.uint32s[1];\r\n        return pos;\r\n    };\r\n    Varint64.readFromBuffer = function (buf, pos) {\r\n        var startPos = pos;\r\n        var hi = 0, lo = 0;\r\n        var i = 0;\r\n        if (buf.byteLength - pos > 4) { // fast route (lo)\r\n            for (; i < 4; ++i) {\r\n                // 1st..4th\r\n                lo = (lo | (buf[pos] & 127) << i * 7) >>> 0;\r\n                if (buf[pos++] < 128)\r\n                    return new Varint64(hi, lo, pos - startPos);\r\n            }\r\n            // 5th\r\n            lo = (lo | (buf[pos] & 127) << 28) >>> 0;\r\n            hi = (hi | (buf[pos] & 127) >> 4) >>> 0;\r\n            if (buf[pos++] < 128)\r\n                return new Varint64(hi, lo, pos - startPos);\r\n            i = 0;\r\n        }\r\n        else {\r\n            for (; i < 3; ++i) {\r\n                /* istanbul ignore if */\r\n                if (pos >= buf.byteLength)\r\n                    throw new Error('Read varint error: index out of range');\r\n                // 1st..3th\r\n                lo = (lo | (buf[pos] & 127) << i * 7) >>> 0;\r\n                if (buf[pos++] < 128)\r\n                    return new Varint64(hi, lo, pos - startPos);\r\n            }\r\n            // 4th\r\n            lo = (lo | (buf[pos++] & 127) << i * 7) >>> 0;\r\n            return new Varint64(hi, lo, pos - startPos);\r\n        }\r\n        if (buf.byteLength - pos > 4) { // fast route (hi)\r\n            for (; i < 5; ++i) {\r\n                // 6th..10th\r\n                hi = (hi | (buf[pos] & 127) << i * 7 + 3) >>> 0;\r\n                if (buf[pos++] < 128)\r\n                    return new Varint64(hi, lo, pos - startPos);\r\n            }\r\n        }\r\n        else {\r\n            for (; i < 5; ++i) {\r\n                /* istanbul ignore if */\r\n                if (pos >= buf.byteLength)\r\n                    throw new Error('Read varint error: index out of range');\r\n                // 6th..10th\r\n                hi = (hi | (buf[pos] & 127) << i * 7 + 3) >>> 0;\r\n                if (buf[pos++] < 128)\r\n                    return new Varint64(hi, lo, pos - startPos);\r\n            }\r\n        }\r\n        /* istanbul ignore next */\r\n        throw Error(\"invalid varint encoding\");\r\n    };\r\n    Varint64.Zero = new Varint64(0, 0);\r\n    return Varint64;\r\n}());\n\nvar BufferReader = /** @class */ (function () {\r\n    function BufferReader() {\r\n        this._pos = 0;\r\n    }\r\n    BufferReader.prototype.load = function (buf, pos) {\r\n        if (pos === void 0) { pos = 0; }\r\n        this._buf = buf;\r\n        this._pos = pos;\r\n        this._view = new DataView(buf.buffer);\r\n    };\r\n    BufferReader.prototype.readVarint = function () {\r\n        var varint = Varint64.readFromBuffer(this._buf, this._pos);\r\n        this._pos += varint.byteLength;\r\n        return varint;\r\n    };\r\n    BufferReader.prototype.readUint = function () {\r\n        return this.readVarint().toNumber(true);\r\n    };\r\n    BufferReader.prototype.readInt = function () {\r\n        return this.readVarint().zzDecode().toNumber();\r\n    };\r\n    BufferReader.prototype.readDouble = function () {\r\n        var pos = this._pos;\r\n        this._pos += 8;\r\n        return this._view.getFloat64(this._buf.byteOffset + pos);\r\n    };\r\n    BufferReader.prototype.readString = function () {\r\n        var strByteLength = this.readUint();\r\n        var str = Utf8Coder.read(this._buf, this._pos, strByteLength);\r\n        this._pos += strByteLength;\r\n        return str;\r\n    };\r\n    BufferReader.prototype.readBuffer = function () {\r\n        var bufByteLength = this.readUint();\r\n        var buf = this._buf.subarray(this._pos, this._pos + bufByteLength);\r\n        this._pos += bufByteLength;\r\n        return buf;\r\n    };\r\n    BufferReader.prototype.skip = function (byteLength) {\r\n        this._pos += byteLength;\r\n    };\r\n    BufferReader.prototype.skipByLengthType = function (lengthType) {\r\n        if (lengthType === LengthType.Bit64) {\r\n            this._pos += 8;\r\n        }\r\n        else if (lengthType === LengthType.Varint) {\r\n            this.readVarint();\r\n        }\r\n        else if (lengthType === LengthType.LengthDelimited) {\r\n            var bufByteLength = this.readUint();\r\n            this._pos += bufByteLength;\r\n        }\r\n        else if (lengthType === LengthType.IdBlock) {\r\n            this.skipIdBlock();\r\n        }\r\n        else {\r\n            throw new Error('Unknown lengthType: ' + lengthType);\r\n        }\r\n    };\r\n    BufferReader.prototype.skipIdBlock = function () {\r\n        var idNum = this.readUint();\r\n        for (var i = 0; i < idNum; ++i) {\r\n            var id = this.readUint();\r\n            var lengthType = id & 3;\r\n            this.skipByLengthType(lengthType);\r\n        }\r\n    };\r\n    BufferReader.prototype.readBoolean = function () {\r\n        var value = this._view.getUint8(this._buf.byteOffset + this._pos++);\r\n        if (value === 255) {\r\n            return true;\r\n        }\r\n        else if (value === 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid boolean encoding [\".concat(value, \"] at pos \").concat(this._pos - 1));\r\n        }\r\n    };\r\n    Object.defineProperty(BufferReader.prototype, \"unreadByteLength\", {\r\n        get: function () {\r\n            return this._buf.byteLength - this._pos;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    BufferReader.prototype.dispose = function () {\r\n        this._buf = this._view = undefined;\r\n    };\r\n    return BufferReader;\r\n}());\n\n/** @internal */\r\nvar Decoder = /** @class */ (function () {\r\n    function Decoder(options) {\r\n        this._options = options;\r\n        this._reader = new BufferReader();\r\n        this._validator = options.validator;\r\n    }\r\n    Decoder.prototype.decode = function (buffer, schema) {\r\n        this._reader.load(buffer);\r\n        return this._read(schema);\r\n    };\r\n    Decoder.prototype.decodeJSON = function (json, schema) {\r\n        var _this = this;\r\n        if (json === null || CoderUtil.isJsonCompatible(schema, 'decode', this._validator.protoHelper)) {\r\n            return json;\r\n        }\r\n        // 递归 只处理 ArrayBuffer、Date、ObjectId\r\n        switch (schema.type) {\r\n            case tsbufferSchema.SchemaType.Array:\r\n                if (!Array.isArray(json)) {\r\n                    break;\r\n                }\r\n                return json.map(function (v) { return _this.decodeJSON(v, schema.elementType); });\r\n            case tsbufferSchema.SchemaType.Tuple:\r\n                if (!Array.isArray(json)) {\r\n                    break;\r\n                }\r\n                return json.map(function (v, i) { return _this.decodeJSON(v, schema.elementTypes[i]); });\r\n            case tsbufferSchema.SchemaType.Interface:\r\n                if (json.constructor !== Object) {\r\n                    break;\r\n                }\r\n                json = Object.assign({}, json);\r\n                var flatSchema = this._validator.protoHelper.getFlatInterfaceSchema(schema);\r\n                var _loop_1 = function (key) {\r\n                    var property = flatSchema.properties.find(function (v) { return v.name === key; });\r\n                    if (property) {\r\n                        json[key] = this_1.decodeJSON(json[key], property.type);\r\n                    }\r\n                    else if (flatSchema.indexSignature) {\r\n                        json[key] = this_1.decodeJSON(json[key], flatSchema.indexSignature.type);\r\n                    }\r\n                };\r\n                var this_1 = this;\r\n                for (var key in json) {\r\n                    _loop_1(key);\r\n                }\r\n                return json;\r\n            case tsbufferSchema.SchemaType.Date:\r\n                if (typeof json !== 'string' && typeof json !== 'number') {\r\n                    break;\r\n                }\r\n                return new Date(json);\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n                var parsed = this._validator.protoHelper.parseMappedType(schema);\r\n                return this.decodeJSON(json, parsed);\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n                if (typeof json !== 'string') {\r\n                    break;\r\n                }\r\n                var uint8Arr = Base64Util.base64ToBuffer(json);\r\n                return this._getBufferValue(uint8Arr, schema);\r\n            case tsbufferSchema.SchemaType.IndexedAccess:\r\n            case tsbufferSchema.SchemaType.Reference:\r\n            case tsbufferSchema.SchemaType.Keyof:\r\n                return this.decodeJSON(json, this._validator.protoHelper.parseReference(schema));\r\n            case tsbufferSchema.SchemaType.Union:\r\n            case tsbufferSchema.SchemaType.Intersection: {\r\n                // 逐个编码 然后合并 （失败的会原值返回，所以不影响结果）\r\n                for (var _i = 0, _a = schema.members; _i < _a.length; _i++) {\r\n                    var member = _a[_i];\r\n                    json = this.decodeJSON(json, member.type);\r\n                }\r\n                return json;\r\n            }\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                return this.decodeJSON(json, schema.target);\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                if (schema.decodeJSON) {\r\n                    return schema.decodeJSON(json);\r\n                }\r\n                break;\r\n            default:\r\n                schema.type;\r\n        }\r\n        return json;\r\n    };\r\n    Decoder.prototype._read = function (schema) {\r\n        switch (schema.type) {\r\n            case tsbufferSchema.SchemaType.Boolean:\r\n                return this._reader.readBoolean();\r\n            case tsbufferSchema.SchemaType.Number:\r\n                return this._readNumber(schema);\r\n            case tsbufferSchema.SchemaType.String:\r\n                return this._reader.readString();\r\n            case tsbufferSchema.SchemaType.Array: {\r\n                var output = [];\r\n                // 数组长度：Varint\r\n                var length_1 = this._reader.readUint();\r\n                for (var i = 0; i < length_1; ++i) {\r\n                    var item = this._read(schema.elementType);\r\n                    output.push(item);\r\n                }\r\n                return output;\r\n            }\r\n            case tsbufferSchema.SchemaType.Tuple: {\r\n                if (schema.elementTypes.length > 64) {\r\n                    throw new Error('Elements oversized, maximum supported tuple elements is 64, now get ' + schema.elementTypes.length);\r\n                }\r\n                var output = [];\r\n                // PayloadMask: Varint64\r\n                var payloadMask = this._reader.readVarint();\r\n                // 计算maskIndices\r\n                var maskIndices = [];\r\n                // Low\r\n                for (var i = 0; i < 32; ++i) {\r\n                    if (payloadMask.uint32s[1] & 1 << i) {\r\n                        maskIndices.push(i);\r\n                    }\r\n                }\r\n                // High\r\n                for (var i = 0; i < 32; ++i) {\r\n                    if (payloadMask.uint32s[0] & 1 << i) {\r\n                        maskIndices.push(i + 32);\r\n                    }\r\n                }\r\n                if (!maskIndices.length) {\r\n                    return [];\r\n                }\r\n                var maxIndex = maskIndices.last();\r\n                for (var i = 0, nextMaskIndex = 0, next = maskIndices[0]; i <= maxIndex; ++i) {\r\n                    if (i === next) {\r\n                        output[i] = this._read(schema.elementTypes[i]);\r\n                        ++nextMaskIndex;\r\n                        next = maskIndices[nextMaskIndex];\r\n                    }\r\n                    else {\r\n                        output[i] = undefined;\r\n                    }\r\n                }\r\n                // undefined as null\r\n                for (var i = 0; i < schema.elementTypes.length; ++i) {\r\n                    if (this._undefinedAsNull(output[i], schema.elementTypes[i], schema.optionalStartIndex !== undefined && i >= schema.optionalStartIndex)) {\r\n                        output[i] = null;\r\n                    }\r\n                }\r\n                return output;\r\n            }\r\n            case tsbufferSchema.SchemaType.Enum:\r\n                var enumId_1 = this._reader.readVarint().toNumber();\r\n                var enumItem = schema.members.find(function (v) { return v.id === enumId_1; });\r\n                if (!enumItem) {\r\n                    throw new Error(\"Invalid enum encoding: unexpected id \".concat(enumId_1));\r\n                }\r\n                return enumItem.value;\r\n            case tsbufferSchema.SchemaType.Any:\r\n            case tsbufferSchema.SchemaType.Object:\r\n                var jsonStr = this._reader.readString();\r\n                if (jsonStr === 'undefined') {\r\n                    return undefined;\r\n                }\r\n                return JSON.parse(jsonStr);\r\n            case tsbufferSchema.SchemaType.Literal:\r\n                return schema.literal;\r\n            case tsbufferSchema.SchemaType.Interface:\r\n                return this._readInterface(schema);\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n                var uint8Arr = this._reader.readBuffer();\r\n                return this._getBufferValue(uint8Arr, schema);\r\n            case tsbufferSchema.SchemaType.IndexedAccess:\r\n            case tsbufferSchema.SchemaType.Reference:\r\n            case tsbufferSchema.SchemaType.Keyof:\r\n                return this._read(this._validator.protoHelper.parseReference(schema));\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n                var parsed = this._validator.protoHelper.parseMappedType(schema);\r\n                if (parsed.type === tsbufferSchema.SchemaType.Interface) {\r\n                    return this._readPureMappedType(schema);\r\n                }\r\n                else {\r\n                    return this._readUnionOrIntersection(parsed);\r\n                }\r\n            case tsbufferSchema.SchemaType.Union:\r\n            case tsbufferSchema.SchemaType.Intersection:\r\n                return this._readUnionOrIntersection(schema);\r\n            case tsbufferSchema.SchemaType.Date:\r\n                return new Date(this._reader.readUint());\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                return this._read(schema.target);\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                if (!schema.decode) {\r\n                    throw new Error('Missing decode method for CustomTypeSchema');\r\n                }\r\n                var buf = this._reader.readBuffer();\r\n                return schema.decode(buf);\r\n            default:\r\n                // @ts-expect-error\r\n                throw new Error(\"Unrecognized schema type: \".concat(schema.type));\r\n        }\r\n    };\r\n    /**\r\n     * PureMappedType 每一层的target 都是MappedType或Interface（最终层）\r\n     */\r\n    Decoder.prototype._readPureMappedType = function (schema) {\r\n        var output;\r\n        var overwrite;\r\n        if (schema.type === 'Overwrite') {\r\n            // Overwrite Block\r\n            overwrite = this._read(schema.overwrite);\r\n        }\r\n        var parsedTarget = this._validator.protoHelper.parseReference(schema.target);\r\n        if (parsedTarget.type === 'Interface') {\r\n            output = this._readInterface(parsedTarget);\r\n        }\r\n        else if (parsedTarget.type === 'Pick' || parsedTarget.type === 'Omit' || parsedTarget.type === 'Partial' || parsedTarget.type === 'Overwrite') {\r\n            output = this._readPureMappedType(parsedTarget);\r\n        }\r\n        else {\r\n            throw new Error('Invalid PureMappedType child: ' + schema.type);\r\n        }\r\n        // filter key\r\n        if (schema.type === 'Pick') {\r\n            // 把Pick以外的剔除\r\n            for (var key in output) {\r\n                if (schema.keys.indexOf(key) === -1) {\r\n                    delete output[key];\r\n                }\r\n            }\r\n        }\r\n        else if (schema.type === 'Omit') {\r\n            // 剔除Omit\r\n            for (var key in output) {\r\n                if (schema.keys.indexOf(key) > -1) {\r\n                    delete output[key];\r\n                }\r\n            }\r\n        }\r\n        else if (schema.type === 'Overwrite') {\r\n            Object.assign(output, overwrite);\r\n        }\r\n        // Partial 原样返回\r\n        return output;\r\n    };\r\n    Decoder.prototype._readNumber = function (schema) {\r\n        // 默认为double\r\n        var scalarType = schema.scalarType || 'double';\r\n        switch (scalarType) {\r\n            // 定长编码\r\n            case 'double':\r\n                return this._reader.readDouble();\r\n            // Varint编码\r\n            case 'int':\r\n                return this._reader.readInt();\r\n            case 'uint':\r\n                return this._reader.readUint();\r\n            default:\r\n                throw new Error('Scalar type not support : ' + scalarType);\r\n        }\r\n    };\r\n    Decoder.prototype._readInterface = function (schema) {\r\n        var output = {};\r\n        var flatSchema = this._validator.protoHelper.getFlatInterfaceSchema(schema);\r\n        // BlockID数量\r\n        var blockIdNum = this._reader.readUint();\r\n        var _loop_2 = function (i) {\r\n            // ReadBlock\r\n            var readBlockId = this_2._reader.readUint();\r\n            var lengthType = readBlockId & 3;\r\n            var blockId = readBlockId >> 2;\r\n            // indexSignature\r\n            if (blockId === 0) {\r\n                if (flatSchema.indexSignature) {\r\n                    var type = flatSchema.indexSignature.type;\r\n                    var fieldName = this_2._reader.readString();\r\n                    this_2._skipIdLengthPrefix(this_2._validator.protoHelper.parseReference(type));\r\n                    output[fieldName] = this_2._read(type);\r\n                }\r\n                // indexSignature未定义，可能是新协议，此处兼容，根据lengthType跳过\r\n                else {\r\n                    // skip fieldName\r\n                    this_2._reader.skipByLengthType(LengthType.LengthDelimited);\r\n                    // skipPayload\r\n                    this_2._reader.skipByLengthType(lengthType);\r\n                }\r\n            }\r\n            // extend block\r\n            else if (blockId <= 9) {\r\n                var extendId_1 = blockId - 1;\r\n                var extend = schema.extends && schema.extends.find(function (v) { return v.id === extendId_1; });\r\n                if (extend) {\r\n                    this_2._skipIdLengthPrefix(this_2._validator.protoHelper.parseReference(extend.type));\r\n                    var extendValue = this_2._read(extend.type);\r\n                    Object.assign(output, extendValue);\r\n                }\r\n                // 未知的extendId 可能是新协议 跳过\r\n                else {\r\n                    // skipPayload\r\n                    this_2._reader.skipByLengthType(lengthType);\r\n                }\r\n            }\r\n            // property\r\n            else {\r\n                var propertyId_1 = blockId - 10;\r\n                var property = schema.properties && schema.properties.find(function (v) { return v.id === propertyId_1; });\r\n                if (property) {\r\n                    this_2._skipIdLengthPrefix(this_2._validator.protoHelper.parseReference(property.type));\r\n                    output[property.name] = this_2._read(property.type);\r\n                }\r\n                // 未知的PropertyID 可能是新协议 跳过\r\n                else {\r\n                    // skipPayload\r\n                    this_2._reader.skipByLengthType(lengthType);\r\n                }\r\n            }\r\n        };\r\n        var this_2 = this;\r\n        for (var i = 0; i < blockIdNum; ++i) {\r\n            _loop_2();\r\n        }\r\n        // Literal property 由于不编码 将其补回\r\n        // undefined as null\r\n        for (var _i = 0, _a = flatSchema.properties; _i < _a.length; _i++) {\r\n            var property = _a[_i];\r\n            if (output.hasOwnProperty(property.name)) {\r\n                continue;\r\n            }\r\n            // Literal\r\n            var parsedType = this._validator.protoHelper.parseReference(property.type);\r\n            if (parsedType.type === 'Literal') {\r\n                output[property.name] = parsedType.literal;\r\n                continue;\r\n            }\r\n            // undefined as null\r\n            if (this._undefinedAsNull(output[property.name], parsedType, property.optional)) {\r\n                output[property.name] = null;\r\n                continue;\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n    /** @internal 是否该null值小于当做undefined编码 */\r\n    Decoder.prototype._undefinedAsNull = function (value, type, isOptional) {\r\n        return value === undefined\r\n            && this._options.undefinedAsNull\r\n            && !SchemaUtil.canBeLiteral(type, undefined) && !isOptional\r\n            && SchemaUtil.canBeLiteral(type, null);\r\n    };\r\n    Decoder.prototype._skipIdLengthPrefix = function (parsedSchema) {\r\n        var lengthInfo = IdBlockUtil.getPayloadLengthInfo(parsedSchema, this._validator.protoHelper);\r\n        if (lengthInfo.needLengthPrefix) {\r\n            // skip length prefix\r\n            this._reader.skipByLengthType(LengthType.Varint);\r\n        }\r\n    };\r\n    Decoder.prototype._readUnionOrIntersection = function (schema) {\r\n        var output;\r\n        var idNum = this._reader.readUint();\r\n        var _loop_3 = function (i) {\r\n            var readId = this_3._reader.readUint();\r\n            var lengthType = readId & 3;\r\n            var id = readId >> 2;\r\n            var member = schema.members.find(function (v) { return v.id === id; });\r\n            // 不可识别的Member，可能是新协议，跳过使兼容\r\n            if (!member) {\r\n                this_3._reader.skipByLengthType(lengthType);\r\n                return \"continue\";\r\n            }\r\n            this_3._skipIdLengthPrefix(this_3._validator.protoHelper.parseReference(member.type));\r\n            var value = this_3._read(member.type);\r\n            if (this_3._isObject(output) && this_3._isObject(value)) {\r\n                Object.assign(output, value);\r\n            }\r\n            else {\r\n                output = value;\r\n            }\r\n        };\r\n        var this_3 = this;\r\n        for (var i = 0; i < idNum; ++i) {\r\n            _loop_3();\r\n        }\r\n        if (this._undefinedAsNull(output, schema)) {\r\n            output = null;\r\n        }\r\n        return output;\r\n    };\r\n    Decoder.prototype._isObject = function (value) {\r\n        return typeof (value) === 'object' && value !== null;\r\n    };\r\n    Decoder.prototype._getBufferValue = function (uint8Arr, schema) {\r\n        if (schema.arrayType) {\r\n            if (schema.arrayType === 'BigInt64Array' || schema.arrayType === 'BigUint64Array') {\r\n                throw new Error('Unsupported arrayType: ' + schema.arrayType);\r\n            }\r\n            // Uint8Array 性能最高\r\n            else if (schema.arrayType === 'Uint8Array') {\r\n                return uint8Arr;\r\n            }\r\n            // 其余TypedArray 可能需要内存拷贝 性能次之\r\n            else {\r\n                var typedArr = TypedArrays[schema.arrayType];\r\n                // 字节对齐，可以直接转，无需拷贝内存\r\n                if (uint8Arr.byteOffset % typedArr.BYTES_PER_ELEMENT === 0) {\r\n                    return new typedArr(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.byteLength / typedArr.BYTES_PER_ELEMENT);\r\n                }\r\n                // 字节不对齐，不能直接转，只能拷贝内存后再生成\r\n                else {\r\n                    var arrBuf = uint8Arr.buffer.slice(uint8Arr.byteOffset, uint8Arr.byteOffset + uint8Arr.byteLength);\r\n                    return new typedArr(arrBuf);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return uint8Arr.byteLength === uint8Arr.buffer.byteLength && uint8Arr.byteOffset === 0 ? uint8Arr.buffer\r\n                : uint8Arr.buffer.slice(uint8Arr.byteOffset, uint8Arr.byteOffset + uint8Arr.byteLength);\r\n        }\r\n    };\r\n    return Decoder;\r\n}());\n\n/** @internal */\r\nvar Config = {\r\n    interface: {\r\n        maxExtendsNum: 9\r\n    }\r\n};\n\n/**\r\n * 用Op来串联 next\r\n * Op包含 function next length\r\n * 先度量长度再执行编码\r\n * 一次性编码\r\n * 使用BufferPool\r\n * writer.uint32(xx).string(xxx).finish();\r\n * @internal\r\n */\r\nvar BufferWriter = /** @class */ (function () {\r\n    function BufferWriter() {\r\n        this._ops = [];\r\n    }\r\n    Object.defineProperty(BufferWriter.prototype, \"ops\", {\r\n        get: function () {\r\n            return this._ops;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    BufferWriter.prototype.clear = function () {\r\n        this._ops = [];\r\n    };\r\n    BufferWriter.prototype.push = function (req) {\r\n        this._ops.push(this.req2op(req));\r\n        return this;\r\n    };\r\n    BufferWriter.prototype.req2op = function (req) {\r\n        if (req.type === 'string' || req.type === 'buffer') {\r\n            var valueLength = this.measureLength(req);\r\n            // Length\r\n            this.push({ type: 'varint', value: Varint64.from(valueLength) });\r\n            // Value\r\n            return tslib.__assign(tslib.__assign({}, req), { length: valueLength });\r\n        }\r\n        else {\r\n            var length_1 = this.measureLength(req);\r\n            return tslib.__assign(tslib.__assign({}, req), { length: length_1 });\r\n        }\r\n    };\r\n    BufferWriter.prototype.measureLength = function (req) {\r\n        switch (req.type) {\r\n            case 'varint':\r\n                return req.value.byteLength;\r\n            case 'string':\r\n                return Utf8Coder.measureLength(req.value);\r\n            case 'buffer':\r\n                return req.value.byteLength;\r\n            case 'double':\r\n                return 8;\r\n            case 'boolean':\r\n                return 1;\r\n            default:\r\n                return NaN;\r\n        }\r\n    };\r\n    BufferWriter.prototype.finish = function () {\r\n        var byteLength = this._ops.sum(function (v) { return v.length; });\r\n        var pos = 0;\r\n        var buf = new Uint8Array(byteLength);\r\n        var view = new DataView(buf.buffer);\r\n        for (var _i = 0, _a = this._ops; _i < _a.length; _i++) {\r\n            var op = _a[_i];\r\n            switch (op.type) {\r\n                case 'varint':\r\n                    var newPos = op.value.writeToBuffer(buf, pos);\r\n                    if (newPos !== pos + op.length) {\r\n                        throw new Error(\"Error varint measuredLength \".concat(op.length, \", actual is \").concat(newPos - pos, \", value is \").concat(op.value.toNumber()));\r\n                    }\r\n                    break;\r\n                case 'double':\r\n                    view.setFloat64(buf.byteOffset + pos, op.value);\r\n                    break;\r\n                case 'string':\r\n                    var encLen = Utf8Coder.write(op.value, buf, pos);\r\n                    if (encLen !== op.length) {\r\n                        throw new Error(\"Expect \".concat(op.length, \" bytes but encoded \").concat(encLen, \" bytes\"));\r\n                    }\r\n                    break;\r\n                case 'buffer':\r\n                    buf.subarray(pos, pos + op.length).set(op.value);\r\n                    break;\r\n                case 'boolean':\r\n                    view.setUint8(buf.byteOffset + pos, op.value ? 255 : 0);\r\n                    break;\r\n            }\r\n            pos += op.length;\r\n        }\r\n        return buf;\r\n    };\r\n    return BufferWriter;\r\n}());\n\n/** @internal */\r\nvar Encoder = /** @class */ (function () {\r\n    function Encoder(options) {\r\n        this._options = options;\r\n        this._writer = new BufferWriter();\r\n        this._validator = options.validator;\r\n    }\r\n    Encoder.prototype.encode = function (value, schema) {\r\n        this._writer.clear();\r\n        this._write(value, schema);\r\n        return this._writer.finish();\r\n    };\r\n    Encoder.prototype.encodeJSON = function (value, schema) {\r\n        var _this = this;\r\n        // JSON 能直接传输的类型，直接跳过\r\n        if (typeof value !== 'object' || value === null || CoderUtil.isJsonCompatible(schema, 'encode', this._validator.protoHelper)) {\r\n            return value;\r\n        }\r\n        switch (schema.type) {\r\n            case tsbufferSchema.SchemaType.Array:\r\n                if (!Array.isArray(value)) {\r\n                    break;\r\n                }\r\n                return value.map(function (v) { return _this.encodeJSON(v, schema.elementType); });\r\n            case tsbufferSchema.SchemaType.Tuple: {\r\n                if (!Array.isArray(value)) {\r\n                    break;\r\n                }\r\n                return value.map(function (v, i) { return _this.encodeJSON(v, schema.elementTypes[i]); });\r\n            }\r\n            case tsbufferSchema.SchemaType.Interface: {\r\n                if (value.constructor !== Object) {\r\n                    break;\r\n                }\r\n                value = Object.assign({}, value);\r\n                var flatSchema = this._validator.protoHelper.getFlatInterfaceSchema(schema);\r\n                var _loop_1 = function (key) {\r\n                    var property = flatSchema.properties.find(function (v) { return v.name === key; });\r\n                    if (property) {\r\n                        value[key] = this_1.encodeJSON(value[key], property.type);\r\n                    }\r\n                    else if (flatSchema.indexSignature) {\r\n                        value[key] = this_1.encodeJSON(value[key], flatSchema.indexSignature.type);\r\n                    }\r\n                };\r\n                var this_1 = this;\r\n                for (var key in value) {\r\n                    _loop_1(key);\r\n                }\r\n                return value;\r\n            }\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n                var parsed = this._validator.protoHelper.parseMappedType(schema);\r\n                return this.encodeJSON(value, parsed);\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n                if (!(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value)) {\r\n                    break;\r\n                }\r\n                if (schema.arrayType) {\r\n                    if (schema.arrayType === 'Uint8Array') {\r\n                        return Base64Util.bufferToBase64(value);\r\n                    }\r\n                    var view = value;\r\n                    var buf = view.byteLength === view.buffer.byteLength && view.byteOffset === 0 ? view.buffer\r\n                        : view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);\r\n                    return Base64Util.bufferToBase64(new Uint8Array(buf));\r\n                }\r\n                else {\r\n                    return Base64Util.bufferToBase64(new Uint8Array(value));\r\n                }\r\n            case tsbufferSchema.SchemaType.IndexedAccess:\r\n            case tsbufferSchema.SchemaType.Reference:\r\n            case tsbufferSchema.SchemaType.Keyof:\r\n                return this.encodeJSON(value, this._validator.protoHelper.parseReference(schema));\r\n            case tsbufferSchema.SchemaType.Union:\r\n            case tsbufferSchema.SchemaType.Intersection: {\r\n                // 逐个编码 然后合并 （失败的会原值返回，所以不影响结果）\r\n                for (var _i = 0, _a = schema.members; _i < _a.length; _i++) {\r\n                    var member = _a[_i];\r\n                    value = this.encodeJSON(value, member.type);\r\n                }\r\n                return value;\r\n            }\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                return this.encodeJSON(value, schema.target);\r\n            case tsbufferSchema.SchemaType.Date:\r\n                if (!(value instanceof Date)) {\r\n                    break;\r\n                }\r\n                return value.toJSON();\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                if (schema.encodeJSON) {\r\n                    return schema.encodeJSON(value);\r\n                }\r\n                else if (typeof (value === null || value === void 0 ? void 0 : value.toJSON) === 'function') {\r\n                    return value.toJSON();\r\n                }\r\n                else if (typeof (value === null || value === void 0 ? void 0 : value.toString) === 'function') {\r\n                    return value.toString();\r\n                }\r\n                return value;\r\n            default:\r\n                schema.type;\r\n        }\r\n        return value;\r\n    };\r\n    Encoder.prototype._write = function (value, schema, options) {\r\n        switch (schema.type) {\r\n            case tsbufferSchema.SchemaType.Boolean:\r\n                this._writer.push({ type: 'boolean', value: value });\r\n                break;\r\n            case tsbufferSchema.SchemaType.Number:\r\n                this._writeNumber(value, schema);\r\n                break;\r\n            case tsbufferSchema.SchemaType.String:\r\n                this._writer.push({ type: 'string', value: value });\r\n                break;\r\n            case tsbufferSchema.SchemaType.Array: {\r\n                var _v = value;\r\n                // 数组长度：Varint\r\n                this._writer.push({ type: 'varint', value: Varint64.from(_v.length) });\r\n                // Element Payload\r\n                for (var i = 0; i < _v.length; ++i) {\r\n                    this._write(_v[i], schema.elementType);\r\n                }\r\n                break;\r\n            }\r\n            case tsbufferSchema.SchemaType.Tuple: {\r\n                if (schema.elementTypes.length > 64) {\r\n                    throw new Error('Elements oversized, maximum supported tuple elements is 64, now get ' + schema.elementTypes.length);\r\n                }\r\n                var _v = value;\r\n                // 计算maskPos（要编码的值的index）\r\n                var maskIndices = [];\r\n                for (var i = 0; i < _v.length; ++i) {\r\n                    // undefined 不编码\r\n                    // null as undefined\r\n                    if (_v[i] === undefined || this._nullAsUndefined(_v[i], schema.elementTypes[i])) {\r\n                        continue;\r\n                    }\r\n                    maskIndices.push(i);\r\n                }\r\n                // 生成PayloadMask：Varint64\r\n                var lo = 0;\r\n                var hi = 0;\r\n                for (var _i = 0, maskIndices_1 = maskIndices; _i < maskIndices_1.length; _i++) {\r\n                    var v = maskIndices_1[_i];\r\n                    if (v < 32) {\r\n                        lo |= 1 << v;\r\n                    }\r\n                    else {\r\n                        hi |= 1 << v - 32;\r\n                    }\r\n                }\r\n                this._writer.push({ type: 'varint', value: new Varint64(hi, lo) });\r\n                // Element Payload\r\n                for (var _a = 0, maskIndices_2 = maskIndices; _a < maskIndices_2.length; _a++) {\r\n                    var i = maskIndices_2[_a];\r\n                    this._write(_v[i], schema.elementTypes[i]);\r\n                }\r\n                break;\r\n            }\r\n            case tsbufferSchema.SchemaType.Enum:\r\n                var enumItem = schema.members.find(function (v) { return v.value === value; });\r\n                if (!enumItem) {\r\n                    throw new Error(\"Unexpect enum value: \".concat(value));\r\n                }\r\n                this._writer.push({ type: 'varint', value: Varint64.from(enumItem.id) });\r\n                break;\r\n            case tsbufferSchema.SchemaType.Any:\r\n                if (value === undefined) {\r\n                    this._writer.push({ type: 'string', value: 'undefined' });\r\n                }\r\n                else {\r\n                    this._writer.push({ type: 'string', value: JSON.stringify(value) });\r\n                }\r\n                break;\r\n            case tsbufferSchema.SchemaType.Object:\r\n                this._writer.push({ type: 'string', value: JSON.stringify(value) });\r\n                break;\r\n            case tsbufferSchema.SchemaType.Literal:\r\n                break;\r\n            case tsbufferSchema.SchemaType.Interface:\r\n                this._writeInterface(value, schema, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Buffer:\r\n                this._writeBuffer(value);\r\n                break;\r\n            case tsbufferSchema.SchemaType.IndexedAccess:\r\n            case tsbufferSchema.SchemaType.Reference:\r\n            case tsbufferSchema.SchemaType.Keyof:\r\n                this._write(value, this._validator.protoHelper.parseReference(schema), options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Partial:\r\n            case tsbufferSchema.SchemaType.Pick:\r\n            case tsbufferSchema.SchemaType.Omit:\r\n            case tsbufferSchema.SchemaType.Overwrite:\r\n                var parsed = this._validator.protoHelper.parseMappedType(schema);\r\n                if (parsed.type === tsbufferSchema.SchemaType.Interface) {\r\n                    this._writePureMappedType(value, schema, options);\r\n                }\r\n                else if (parsed.type === tsbufferSchema.SchemaType.Union) {\r\n                    this._writeUnion(value, parsed, options === null || options === void 0 ? void 0 : options.skipFields);\r\n                }\r\n                else if (parsed.type === tsbufferSchema.SchemaType.Intersection) {\r\n                    this._writeIntersection(value, parsed, options === null || options === void 0 ? void 0 : options.skipFields);\r\n                }\r\n                break;\r\n            case tsbufferSchema.SchemaType.Union:\r\n                this._writeUnion(value, schema, options === null || options === void 0 ? void 0 : options.skipFields);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Intersection:\r\n                this._writeIntersection(value, schema, options === null || options === void 0 ? void 0 : options.skipFields);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Date:\r\n                this._writer.push({ type: 'varint', value: Varint64.from(value.getTime()) });\r\n                break;\r\n            case tsbufferSchema.SchemaType.NonNullable:\r\n                this._write(value, schema.target, options);\r\n                break;\r\n            case tsbufferSchema.SchemaType.Custom:\r\n                if (!schema.encode) {\r\n                    throw new Error('Missing encode method for CustomTypeSchema');\r\n                }\r\n                var buf = schema.encode(value);\r\n                // 以 Buffer 形式写入\r\n                this._writeBuffer(buf);\r\n                break;\r\n            default:\r\n                // @ts-expect-error\r\n                throw new Error(\"Unrecognized schema type: \".concat(schema.type));\r\n        }\r\n    };\r\n    Encoder.prototype._writePureMappedType = function (value, schema, options) {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (schema.type === 'Pick') {\r\n            // 已存在 取交集\r\n            if (options.pickFields) {\r\n                var newPickFields = {};\r\n                for (var _i = 0, _a = schema.keys; _i < _a.length; _i++) {\r\n                    var v = _a[_i];\r\n                    if (options.pickFields[v]) {\r\n                        newPickFields[v] = 1;\r\n                    }\r\n                }\r\n                options.pickFields = newPickFields;\r\n            }\r\n            // 不存在 初始化\r\n            else {\r\n                options.pickFields = {};\r\n                for (var _b = 0, _c = schema.keys; _b < _c.length; _b++) {\r\n                    var v = _c[_b];\r\n                    options.pickFields[v] = 1;\r\n                }\r\n            }\r\n        }\r\n        else if (schema.type === 'Omit') {\r\n            // 不存在 初始化\r\n            if (!(options === null || options === void 0 ? void 0 : options.skipFields)) {\r\n                if (!options) {\r\n                    options = {};\r\n                }\r\n                options.skipFields = {};\r\n            }\r\n            // 取并集                \r\n            for (var _d = 0, _e = schema.keys; _d < _e.length; _d++) {\r\n                var v = _e[_d];\r\n                options.skipFields[v] = 1;\r\n            }\r\n        }\r\n        else if (schema.type === 'Overwrite') {\r\n            var parsed = this._parseOverwrite(value, schema);\r\n            // 写入Overwrite部分\r\n            this._write(parsed.overwriteValue, parsed.overwrite, options);\r\n        }\r\n        else if (schema.type === 'Partial') ;\r\n        else {\r\n            // @ts-expect-error\r\n            throw new Error('Invalid PureMappedType child: ' + schema.type);\r\n        }\r\n        // Write Interface\r\n        var parsedTarget = this._validator.protoHelper.parseReference(schema.target);\r\n        if (parsedTarget.type === 'Interface') {\r\n            this._writeInterface(value, parsedTarget, options);\r\n        }\r\n        else {\r\n            this._writePureMappedType(value, parsedTarget, options);\r\n        }\r\n    };\r\n    Encoder.prototype._writeNumber = function (value, schema) {\r\n        // 默认为double\r\n        var scalarType = schema.scalarType || 'double';\r\n        switch (scalarType) {\r\n            // 定长编码\r\n            case 'double':\r\n                this._writer.push({ type: scalarType, value: value });\r\n                break;\r\n            // Varint编码\r\n            case 'int':\r\n                this._writer.push({ type: 'varint', value: Varint64.from(value).zzEncode() });\r\n                break;\r\n            case 'uint':\r\n                this._writer.push({ type: 'varint', value: Varint64.from(value) });\r\n                break;\r\n            default:\r\n                throw new Error('Scalar type not support : ' + scalarType);\r\n        }\r\n    };\r\n    Encoder.prototype._writeInterface = function (value, schema, options) {\r\n        // skipFields默认值\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (!options.skipFields) {\r\n            options.skipFields = {};\r\n        }\r\n        // 记录起始op位置，用于最后插入BlockID数量\r\n        var opStartOps = this._writer.ops.length;\r\n        var blockIdCount = 0;\r\n        // 以下，interface\r\n        // extends\r\n        if (schema.extends) {\r\n            // 支持的继承数量有上限\r\n            if (schema.extends.length > Config.interface.maxExtendsNum) {\r\n                throw new Error(\"Max support \".concat(Config.interface.maxExtendsNum, \" extends, actual: \").concat(schema.extends.length));\r\n            }\r\n            for (var _i = 0, _a = schema.extends; _i < _a.length; _i++) {\r\n                var extend = _a[_i];\r\n                // BlockID = extend.id + 1\r\n                var blockId = extend.id + 1;\r\n                this._writer.push({ type: 'varint', value: Varint64.from(blockId) });\r\n                var blockIdPos = this._writer.ops.length - 1;\r\n                // 写入extend interface前 writeOps的长度\r\n                var opsLengthBeforeWrite = this._writer.ops.length;\r\n                // extend Block\r\n                var parsedExtend = this._validator.protoHelper.parseReference(extend.type);\r\n                this._writeInterface(value, parsedExtend, tslib.__assign(tslib.__assign({}, options), { \r\n                    // 确保indexSignature是在最小层级编码\r\n                    skipIndexSignature: !!schema.indexSignature || options.skipIndexSignature // 如果父级有indexSignature 或 父级跳过 则跳过indexSignature\r\n                 }));\r\n                // 写入前后writeOps只增加了一个（block length），说明该extend并未写入任何property字段，取消编码这个block\r\n                if (this._writer.ops.length === opsLengthBeforeWrite + 1) {\r\n                    // 移除BlockID\r\n                    this._writer.ops.splice(this._writer.ops.length - 2, 2);\r\n                }\r\n                // extend写入成功 blockId数量+1\r\n                else {\r\n                    ++blockIdCount;\r\n                    this._processIdWithLengthType(blockIdPos, extend.type);\r\n                }\r\n            }\r\n        }\r\n        // property\r\n        if (schema.properties) {\r\n            for (var _b = 0, _c = schema.properties; _b < _c.length; _b++) {\r\n                var property = _c[_b];\r\n                var parsedType = this._validator.protoHelper.parseReference(property.type);\r\n                var propValue = value[property.name];\r\n                // PickFields\r\n                if (options.pickFields && !options.pickFields[property.name]) {\r\n                    continue;\r\n                }\r\n                // Literal不编码 直接跳过\r\n                if (parsedType.type === 'Literal') {\r\n                    options.skipFields[property.name] = 1;\r\n                    continue;\r\n                }\r\n                // null as undefined\r\n                if (this._nullAsUndefined(propValue, property.type)) {\r\n                    propValue = undefined;\r\n                }\r\n                // undefined不编码\r\n                if (propValue === undefined) {\r\n                    continue;\r\n                }\r\n                // SkipFields\r\n                if (options.skipFields[property.name]) {\r\n                    continue;\r\n                }\r\n                options.skipFields[property.name] = 1;\r\n                var blockId = property.id + Config.interface.maxExtendsNum + 1;\r\n                // BlockID (propertyID)\r\n                this._writer.push({ type: 'varint', value: Varint64.from(blockId) });\r\n                var blockIdPos = this._writer.ops.length - 1;\r\n                // Value Payload\r\n                this._write(propValue, parsedType);\r\n                ++blockIdCount;\r\n                this._processIdWithLengthType(blockIdPos, parsedType);\r\n            }\r\n        }\r\n        // indexSignature\r\n        if (!options.skipIndexSignature) {\r\n            var flat = this._validator.protoHelper.getFlatInterfaceSchema(schema);\r\n            if (flat.indexSignature) {\r\n                for (var key in value) {\r\n                    if (value[key] === undefined || this._nullAsUndefined(value[key], flat.indexSignature.type)) {\r\n                        continue;\r\n                    }\r\n                    // PickFields\r\n                    if (options.pickFields && !options.pickFields[key]) {\r\n                        continue;\r\n                    }\r\n                    // SkipFields\r\n                    if (options.skipFields[key]) {\r\n                        continue;\r\n                    }\r\n                    options.skipFields[key] = 1;\r\n                    // BlockID == 0\r\n                    this._writer.push({ type: 'varint', value: Varint64.from(0) });\r\n                    var blockIdPos = this._writer.ops.length - 1;\r\n                    // 字段名\r\n                    this._writer.push({ type: 'string', value: key });\r\n                    var lengthPrefixPos = this._writer.ops.length;\r\n                    // Value Payload\r\n                    this._write(value[key], flat.indexSignature.type);\r\n                    ++blockIdCount;\r\n                    this._processIdWithLengthType(blockIdPos, flat.indexSignature.type, lengthPrefixPos);\r\n                }\r\n            }\r\n        }\r\n        this._writer.ops.splice(opStartOps, 0, this._writer.req2op({ type: 'varint', value: Varint64.from(blockIdCount) }));\r\n    };\r\n    /** @internal 是否该null值小于当做undefined编码 */\r\n    Encoder.prototype._nullAsUndefined = function (value, type) {\r\n        return value === null\r\n            && this._options.nullAsUndefined\r\n            && !SchemaUtil.canBeLiteral(type, null);\r\n        // && SchemaUtil.canBeLiteral(type, undefined)  一定为true 因为先validate过了\r\n    };\r\n    Encoder.prototype._parseOverwrite = function (value, schema) {\r\n        var skipFields = {};\r\n        // 解引用\r\n        var target = this._validator.protoHelper.parseReference(schema.target);\r\n        var overwrite = this._validator.protoHelper.parseReference(schema.overwrite);\r\n        var flatTarget = this._validator.protoHelper.getFlatInterfaceSchema(target);\r\n        var flatOverwrite = this._validator.protoHelper.getFlatInterfaceSchema(overwrite);\r\n        // 先区分哪些字段进入Target块，哪些字段进入Overwrite块\r\n        var overwriteValue = {};\r\n        var targetValue = {};\r\n        // Overwrite块 property\r\n        if (flatOverwrite.properties) {\r\n            // 只要Overwrite中有此Property，即在Overwrite块编码\r\n            for (var _i = 0, _a = flatOverwrite.properties; _i < _a.length; _i++) {\r\n                var property = _a[_i];\r\n                // undefined不编码，跳过SkipFIelds\r\n                if (value[property.name] !== undefined && !skipFields[property.name]) {\r\n                    overwriteValue[property.name] = value[property.name];\r\n                    skipFields[property.name] = 1;\r\n                }\r\n            }\r\n        }\r\n        // Target块 property\r\n        if (flatTarget.properties) {\r\n            for (var _b = 0, _c = flatTarget.properties; _b < _c.length; _b++) {\r\n                var property = _c[_b];\r\n                // undefined不编码，跳过SkipFields\r\n                if (value[property.name] !== undefined && !skipFields[property.name]) {\r\n                    targetValue[property.name] = value[property.name];\r\n                    skipFields[property.name] = 1;\r\n                }\r\n            }\r\n        }\r\n        // indexSignature\r\n        var indexSignatureWriteValue; // indexSignature要写入的目标（overwrite或target）\r\n        var indexSignature;\r\n        // IndexSignature，优先使用Overwrite的\r\n        if (flatOverwrite.indexSignature) {\r\n            indexSignature = flatOverwrite.indexSignature;\r\n            indexSignatureWriteValue = overwriteValue;\r\n        }\r\n        else if (flatTarget.indexSignature) {\r\n            indexSignature = flatTarget.indexSignature;\r\n            indexSignatureWriteValue = targetValue;\r\n        }\r\n        if (indexSignature) {\r\n            for (var key in value) {\r\n                if (skipFields[key]) {\r\n                    continue;\r\n                }\r\n                indexSignatureWriteValue[key] = value[key];\r\n                skipFields[key] = 1;\r\n            }\r\n        }\r\n        // 编码，此处不再需要SkipFields，因为已经筛选过\r\n        return {\r\n            target: target,\r\n            targetValue: targetValue,\r\n            overwrite: overwrite,\r\n            overwriteValue: overwriteValue\r\n        };\r\n    };\r\n    Encoder.prototype._writeUnion = function (value, schema, skipFields, unionProperties) {\r\n        // 计算unionProperties\r\n        // if (!unionProperties) {\r\n        //     unionProperties = skipFields ? Object.keys(skipFields) : [];\r\n        // }\r\n        // this._validator.protoHelper.getUnionProperties(schema).forEach(v => {\r\n        //     unionProperties!.binaryInsert(v, true);\r\n        // })\r\n        if (skipFields === void 0) { skipFields = {}; }\r\n        // 记住编码起点\r\n        var encodeStartPos = this._writer.ops.length;\r\n        var idNum = 0;\r\n        // null as undefined\r\n        if (this._nullAsUndefined(value, schema)) {\r\n            value = undefined;\r\n        }\r\n        for (var _i = 0, _a = schema.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            // 验证该member是否可以编码            \r\n            var vRes = this._validator.validate(value, member.type, {\r\n                // 禁用excessPropertyChecks（以代替unionProperties）\r\n                excessPropertyChecks: false,\r\n                // 启用strictNullChecks（null as undefined已经前置处理）\r\n                // strictNullChecks: true\r\n            });\r\n            if (vRes.isSucc) {\r\n                // 编码\r\n                // Part2: ID\r\n                this._writer.push({ type: 'varint', value: Varint64.from(member.id) });\r\n                var idPos = this._writer.ops.length - 1;\r\n                // Part3: Payload\r\n                if (member.type.type === 'Union') {\r\n                    this._writeUnion(value, member.type, skipFields);\r\n                }\r\n                else {\r\n                    this._write(value, member.type, {\r\n                        skipFields: skipFields\r\n                    });\r\n                }\r\n                idNum++;\r\n                this._processIdWithLengthType(idPos, member.type);\r\n                // 非object的value，类型一定互斥，只编码一个足矣\r\n                if (typeof value !== 'object') {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // 已经编码\r\n        if (idNum > 0) {\r\n            // 前置ID数量\r\n            this._writer.ops.splice(encodeStartPos, 0, this._writer.req2op({ type: 'varint', value: Varint64.from(idNum) }));\r\n            return;\r\n        }\r\n        else {\r\n            // 未编码，没有任何条件满足，抛出异常\r\n            throw new Error('Non member is satisfied for union type');\r\n        }\r\n    };\r\n    Encoder.prototype._writeIntersection = function (value, schema, skipFields) {\r\n        if (skipFields === void 0) { skipFields = {}; }\r\n        // ID数量（member数量）\r\n        this._writer.push({ type: 'varint', value: Varint64.from(schema.members.length) });\r\n        // 按Member依次编码\r\n        for (var _i = 0, _a = schema.members; _i < _a.length; _i++) {\r\n            var member = _a[_i];\r\n            // ID\r\n            this._writer.push({ type: 'varint', value: Varint64.from(member.id) });\r\n            var idPos = this._writer.ops.length - 1;\r\n            // 编码块\r\n            this._write(value, member.type, {\r\n                skipFields: skipFields\r\n            });\r\n            this._processIdWithLengthType(idPos, member.type);\r\n        }\r\n    };\r\n    Encoder.prototype._writeBuffer = function (value) {\r\n        // ArrayBuffer 转为Uint8Array\r\n        if (value instanceof ArrayBuffer) {\r\n            this._writer.push({ type: 'buffer', value: new Uint8Array(value) });\r\n        }\r\n        // Uint8Array 直接写入\r\n        else if (value instanceof Uint8Array) {\r\n            this._writer.push({ type: 'buffer', value: value });\r\n        }\r\n        // 其它TypedArray 转为Uint8Array\r\n        else {\r\n            var key = value.constructor.name;\r\n            var arrType = TypedArrays[key];\r\n            var uint8Arr = new Uint8Array(value.buffer, value.byteOffset, value.length * arrType.BYTES_PER_ELEMENT);\r\n            this._writer.push({ type: 'buffer', value: uint8Arr });\r\n        }\r\n    };\r\n    // private _writeIdBlocks(blocks: IDBlockItem[]) {\r\n    //     // 字段数量: Varint\r\n    //     this._writer.push({ type: 'varint', value: Varint64.from(blocks.length) });\r\n    //     // 依次编码\r\n    //     for (let item of blocks) {\r\n    //         // ID\r\n    //         this._writer.push({ type: 'varint', value: Varint64.from(item.id) });\r\n    //         // Payload\r\n    //         this._write(item.value, item.schema)\r\n    //     }\r\n    // }\r\n    /**\r\n     * 重新处理ID位，使其加入末位长度信息2Bit\r\n     * @param idPos\r\n     */\r\n    Encoder.prototype._processIdWithLengthType = function (idPos, payloadType, lengthPrefixPos) {\r\n        var idOp = this._writer.ops[idPos];\r\n        if (idOp.type !== 'varint') {\r\n            throw new Error('Error idPos: ' + idPos);\r\n        }\r\n        // 解引用\r\n        var parsedSchema = this._validator.protoHelper.parseReference(payloadType);\r\n        var lengthInfo = IdBlockUtil.getPayloadLengthInfo(parsedSchema, this._validator.protoHelper);\r\n        var newId = (idOp.value.toNumber() << 2) + lengthInfo.lengthType;\r\n        this._writer.ops[idPos] = this._writer.req2op({\r\n            type: 'varint',\r\n            value: Varint64.from(newId)\r\n        });\r\n        if (lengthInfo.needLengthPrefix) {\r\n            var payloadByteLength = this._writer.ops.filter(function (v, i) { return i > idPos; }).sum(function (v) { return v.length; });\r\n            this._writer.ops.splice(lengthPrefixPos == undefined ? idPos + 1 : lengthPrefixPos, 0, this._writer.req2op({\r\n                type: 'varint',\r\n                value: Varint64.from(payloadByteLength)\r\n            }));\r\n        }\r\n    };\r\n    return Encoder;\r\n}());\n\n/**\r\n * @public\r\n */\r\nvar TSBuffer = /** @class */ (function () {\r\n    function TSBuffer(proto, options) {\r\n        /** @internal 默认配置 */\r\n        this._options = {\r\n            excessPropertyChecks: true,\r\n            strictNullChecks: false,\r\n            skipEncodeValidate: false,\r\n            skipDecodeValidate: false,\r\n            cloneProto: true,\r\n        };\r\n        // but `options.validatorOptions` has higher priority to validate process (don't affect encode)\r\n        this._options = tslib.__assign(tslib.__assign({}, this._options), options);\r\n        this._proto = this._options.cloneProto ? Object.merge({}, proto) : proto;\r\n        Object.assign(this._proto, Object.merge({}, options === null || options === void 0 ? void 0 : options.customTypes));\r\n        this._validator = new tsbufferValidator.TSBufferValidator(this._proto, {\r\n            excessPropertyChecks: this._options.excessPropertyChecks,\r\n            strictNullChecks: this._options.strictNullChecks,\r\n            cloneProto: false\r\n        });\r\n        this.validate = this._validator.validate.bind(this._validator);\r\n        this.prune = this._validator.prune.bind(this._validator);\r\n        this._encoder = new Encoder({\r\n            validator: this._validator,\r\n            // if !strictNullChecks, then encoder can convert null to undefined\r\n            nullAsUndefined: !this._options.strictNullChecks\r\n        });\r\n        this._decoder = new Decoder({\r\n            validator: this._validator,\r\n            // if !strictNullChecks, then decoder can convert undefined to null\r\n            undefinedAsNull: !this._options.strictNullChecks\r\n        });\r\n    }\r\n    /**\r\n     * 编码\r\n     * @param value - 要编码的值\r\n     * @param schemaOrId - Schema 或 SchemaID，例如`a/b.ts`下的`Test`类型，其ID为`a/b/Test`\r\n     */\r\n    TSBuffer.prototype.encode = function (value, schemaOrId, options) {\r\n        var _a;\r\n        var schema;\r\n        if (typeof schemaOrId === 'string') {\r\n            schema = this._proto[schemaOrId];\r\n            if (!schema) {\r\n                return { isSucc: false, errMsg: \"Cannot find schema\\uFF1A \".concat(schemaOrId) };\r\n            }\r\n        }\r\n        else {\r\n            schema = schemaOrId;\r\n        }\r\n        // validate before encode\r\n        if (!((_a = options === null || options === void 0 ? void 0 : options.skipValidate) !== null && _a !== void 0 ? _a : this._options.skipEncodeValidate)) {\r\n            var vRes = this._validator.validate(value, schema, {\r\n                // 禁用excessPropertyChecks，因为不会编码excess property\r\n                excessPropertyChecks: false\r\n            });\r\n            if (!vRes.isSucc) {\r\n                return vRes;\r\n            }\r\n        }\r\n        var buf;\r\n        try {\r\n            buf = this._encoder.encode(value, schema);\r\n        }\r\n        catch (e) {\r\n            return { isSucc: false, errMsg: e.message };\r\n        }\r\n        return { isSucc: true, buf: buf };\r\n    };\r\n    /**\r\n     * 解码\r\n     * @param buf - 待解码的二进制数据\r\n     * @param schemaOrId - Schema 或 SchemaID，例如`a/b.ts`下的`Test`类型，其ID为`a/b/Test`\r\n     */\r\n    TSBuffer.prototype.decode = function (buf, schemaOrId, options) {\r\n        var _a;\r\n        var schema;\r\n        if (typeof schemaOrId === 'string') {\r\n            schema = this._proto[schemaOrId];\r\n            if (!schema) {\r\n                return { isSucc: false, errMsg: \"Cannot find schema\\uFF1A \".concat(schemaOrId), errPhase: undefined };\r\n            }\r\n        }\r\n        else {\r\n            schema = schemaOrId;\r\n        }\r\n        var value;\r\n        try {\r\n            value = this._decoder.decode(buf, schema);\r\n        }\r\n        catch (e) {\r\n            return { isSucc: false, errMsg: e.message, errPhase: 'decode' };\r\n        }\r\n        if (!((_a = options === null || options === void 0 ? void 0 : options.skipValidate) !== null && _a !== void 0 ? _a : this._options.skipDecodeValidate)) {\r\n            var vRes = this._validator.validate(value, schema);\r\n            if (!vRes.isSucc) {\r\n                return tslib.__assign(tslib.__assign({}, vRes), { errPhase: 'validate' });\r\n            }\r\n        }\r\n        return { isSucc: true, value: value };\r\n    };\r\n    /**\r\n     * 编码为 JSON Object，根据协议将 JSON 不支持的格式（如 ArrayBuffer、Date、ObjectId）转换成 JSON 可传输的格式\r\n     * @param value\r\n     * @param schemaOrId\r\n     * @param options\r\n     */\r\n    TSBuffer.prototype.encodeJSON = function (value, schemaOrId, options) {\r\n        var _a;\r\n        var schema;\r\n        if (typeof schemaOrId === 'string') {\r\n            schema = this._proto[schemaOrId];\r\n            if (!schema) {\r\n                return { isSucc: false, errMsg: \"Cannot find schema\\uFF1A \".concat(schemaOrId) };\r\n            }\r\n        }\r\n        else {\r\n            schema = schemaOrId;\r\n        }\r\n        // validate before encode\r\n        if (!((_a = options === null || options === void 0 ? void 0 : options.skipValidate) !== null && _a !== void 0 ? _a : this._options.skipEncodeValidate)) {\r\n            var vRes = this._validator.prune(value, schema);\r\n            if (!vRes.isSucc) {\r\n                return vRes;\r\n            }\r\n            value = vRes.pruneOutput;\r\n        }\r\n        // TODO schema 里没有 Buffer 和 Custom 的自动跳过\r\n        var json;\r\n        try {\r\n            json = this._encoder.encodeJSON(value, schema);\r\n        }\r\n        catch (e) {\r\n            return { isSucc: false, errMsg: e.message };\r\n        }\r\n        return { isSucc: true, json: json };\r\n    };\r\n    /**\r\n     * 从 JSON Object 解码，根据协议将 ArrayBuffer、Date、ObjectId 等类型从 JSON 中还原\r\n     * @param json - JSON Object (是 JSON 对象，而非 JSON 字符串)\r\n     * @param schemaOrId\r\n     * @param options\r\n     */\r\n    TSBuffer.prototype.decodeJSON = function (json, schemaOrId, options) {\r\n        var _a;\r\n        var schema;\r\n        if (typeof schemaOrId === 'string') {\r\n            schema = this._proto[schemaOrId];\r\n            if (!schema) {\r\n                return { isSucc: false, errMsg: \"Cannot find schema\\uFF1A \".concat(schemaOrId), errPhase: undefined };\r\n            }\r\n        }\r\n        else {\r\n            schema = schemaOrId;\r\n        }\r\n        // TODO schema 里没有 Buffer 和 Custom 的自动跳过\r\n        var value;\r\n        try {\r\n            value = this._decoder.decodeJSON(json, schema);\r\n        }\r\n        catch (e) {\r\n            return { isSucc: false, errMsg: e.message, errPhase: 'decode' };\r\n        }\r\n        if (!((_a = options === null || options === void 0 ? void 0 : options.skipValidate) !== null && _a !== void 0 ? _a : this._options.skipDecodeValidate)) {\r\n            var vRes = this._validator.prune(value, schema);\r\n            if (!vRes.isSucc) {\r\n                vRes.errPhase = 'validate';\r\n                return vRes;\r\n            }\r\n            return { isSucc: true, value: vRes.pruneOutput };\r\n        }\r\n        return { isSucc: true, value: value };\r\n    };\r\n    return TSBuffer;\r\n}());\n\nexports.Base64Util = Base64Util;\nexports.TSBuffer = TSBuffer;\n"]}